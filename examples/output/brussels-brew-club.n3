@prefix : <http://example.org/brewclub#> .
@prefix genid: <https://eyereasoner.github.io/.well-known/genid/> .
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> .
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :bob :age 16 .
# It holds because the following instance of the rule body is provable:
#   :bob :profileJson """{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/age") string:jsonPointer 16 .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/name") string:jsonPointer "Bob" .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/city") string:jsonPointer "Brussels" .
# via the schematic forward rule:
#   {
#     ?p :profileJson ?j .
#     (?j "/age") string:jsonPointer ?age .
#     (?j "/name") string:jsonPointer ?name .
#     (?j "/city") string:jsonPointer ?city .
#   } => {
#     ?p :age ?age .
#     ?p :name ?name .
#     ?p :city ?city .
#   } .
# with substitution (on rule variables):
#   ?age = 16
#   ?city = "Brussels"
#   ?j = """{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON
#   ?name = "Bob"
#   ?p = :bob
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:bob :age 16 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :bob :name "Bob" .
# It holds because the following instance of the rule body is provable:
#   :bob :profileJson """{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/age") string:jsonPointer 16 .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/name") string:jsonPointer "Bob" .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/city") string:jsonPointer "Brussels" .
# via the schematic forward rule:
#   {
#     ?p :profileJson ?j .
#     (?j "/age") string:jsonPointer ?age .
#     (?j "/name") string:jsonPointer ?name .
#     (?j "/city") string:jsonPointer ?city .
#   } => {
#     ?p :age ?age .
#     ?p :name ?name .
#     ?p :city ?city .
#   } .
# with substitution (on rule variables):
#   ?age = 16
#   ?city = "Brussels"
#   ?j = """{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON
#   ?name = "Bob"
#   ?p = :bob
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:bob :name "Bob" .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :bob :city "Brussels" .
# It holds because the following instance of the rule body is provable:
#   :bob :profileJson """{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/age") string:jsonPointer 16 .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/name") string:jsonPointer "Bob" .
#   ("""{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON "/city") string:jsonPointer "Brussels" .
# via the schematic forward rule:
#   {
#     ?p :profileJson ?j .
#     (?j "/age") string:jsonPointer ?age .
#     (?j "/name") string:jsonPointer ?name .
#     (?j "/city") string:jsonPointer ?city .
#   } => {
#     ?p :age ?age .
#     ?p :name ?name .
#     ?p :city ?city .
#   } .
# with substitution (on rule variables):
#   ?age = 16
#   ?city = "Brussels"
#   ?j = """{ "name": "Bob",   "age": 16, "city": "Brussels" }"""^^rdf:JSON
#   ?name = "Bob"
#   ?p = :bob
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:bob :city "Brussels" .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :alice :age 23 .
# It holds because the following instance of the rule body is provable:
#   :alice :profileJson """{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/age") string:jsonPointer 23 .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/name") string:jsonPointer "Alice" .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/city") string:jsonPointer "Brussels" .
# via the schematic forward rule:
#   {
#     ?p :profileJson ?j .
#     (?j "/age") string:jsonPointer ?age .
#     (?j "/name") string:jsonPointer ?name .
#     (?j "/city") string:jsonPointer ?city .
#   } => {
#     ?p :age ?age .
#     ?p :name ?name .
#     ?p :city ?city .
#   } .
# with substitution (on rule variables):
#   ?age = 23
#   ?city = "Brussels"
#   ?j = """{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON
#   ?name = "Alice"
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:alice :age 23 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :alice :name "Alice" .
# It holds because the following instance of the rule body is provable:
#   :alice :profileJson """{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/age") string:jsonPointer 23 .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/name") string:jsonPointer "Alice" .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/city") string:jsonPointer "Brussels" .
# via the schematic forward rule:
#   {
#     ?p :profileJson ?j .
#     (?j "/age") string:jsonPointer ?age .
#     (?j "/name") string:jsonPointer ?name .
#     (?j "/city") string:jsonPointer ?city .
#   } => {
#     ?p :age ?age .
#     ?p :name ?name .
#     ?p :city ?city .
#   } .
# with substitution (on rule variables):
#   ?age = 23
#   ?city = "Brussels"
#   ?j = """{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON
#   ?name = "Alice"
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:alice :name "Alice" .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :alice :city "Brussels" .
# It holds because the following instance of the rule body is provable:
#   :alice :profileJson """{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/age") string:jsonPointer 23 .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/name") string:jsonPointer "Alice" .
#   ("""{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON "/city") string:jsonPointer "Brussels" .
# via the schematic forward rule:
#   {
#     ?p :profileJson ?j .
#     (?j "/age") string:jsonPointer ?age .
#     (?j "/name") string:jsonPointer ?name .
#     (?j "/city") string:jsonPointer ?city .
#   } => {
#     ?p :age ?age .
#     ?p :name ?name .
#     ?p :city ?city .
#   } .
# with substitution (on rule variables):
#   ?age = 23
#   ?city = "Brussels"
#   ?j = """{ "name": "Alice", "age": 23, "city": "Brussels" }"""^^rdf:JSON
#   ?name = "Alice"
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:alice :city "Brussels" .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 a :MembershipCard .
# It holds because the following instance of the rule body is provable:
#   :alice a :Adult .
#   :alice :name "Alice" .
#   ?_b1 time:localTime "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime .
#   (:alice) log:skolem genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 .
#   ("Brew Club card for " "Alice") string:concatenation "Brew Club card for Alice" .
# via the schematic forward rule:
#   {
#     ?p a :Adult .
#     ?p :name ?name .
#     ?_b1 time:localTime ?now .
#     (?p) log:skolem ?card .
#     ("Brew Club card for " ?name) string:concatenation ?label .
#   } => {
#     ?card a :MembershipCard .
#     ?card :holder ?p .
#     ?card :issuedAt ?now .
#     ?card rdfs:label ?label .
#   } .
# with substitution (on rule variables):
#   ?card = genid:9e06e026-ada3-9430-3e11-8dd8c37dac24
#   ?label = "Brew Club card for Alice"
#   ?name = "Alice"
#   ?now = "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 a :MembershipCard .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 :holder :alice .
# It holds because the following instance of the rule body is provable:
#   :alice a :Adult .
#   :alice :name "Alice" .
#   ?_b1 time:localTime "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime .
#   (:alice) log:skolem genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 .
#   ("Brew Club card for " "Alice") string:concatenation "Brew Club card for Alice" .
# via the schematic forward rule:
#   {
#     ?p a :Adult .
#     ?p :name ?name .
#     ?_b1 time:localTime ?now .
#     (?p) log:skolem ?card .
#     ("Brew Club card for " ?name) string:concatenation ?label .
#   } => {
#     ?card a :MembershipCard .
#     ?card :holder ?p .
#     ?card :issuedAt ?now .
#     ?card rdfs:label ?label .
#   } .
# with substitution (on rule variables):
#   ?card = genid:9e06e026-ada3-9430-3e11-8dd8c37dac24
#   ?label = "Brew Club card for Alice"
#   ?name = "Alice"
#   ?now = "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 :holder :alice .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 :issuedAt "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime .
# It holds because the following instance of the rule body is provable:
#   :alice a :Adult .
#   :alice :name "Alice" .
#   ?_b1 time:localTime "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime .
#   (:alice) log:skolem genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 .
#   ("Brew Club card for " "Alice") string:concatenation "Brew Club card for Alice" .
# via the schematic forward rule:
#   {
#     ?p a :Adult .
#     ?p :name ?name .
#     ?_b1 time:localTime ?now .
#     (?p) log:skolem ?card .
#     ("Brew Club card for " ?name) string:concatenation ?label .
#   } => {
#     ?card a :MembershipCard .
#     ?card :holder ?p .
#     ?card :issuedAt ?now .
#     ?card rdfs:label ?label .
#   } .
# with substitution (on rule variables):
#   ?card = genid:9e06e026-ada3-9430-3e11-8dd8c37dac24
#   ?label = "Brew Club card for Alice"
#   ?name = "Alice"
#   ?now = "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 :issuedAt "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 rdfs:label "Brew Club card for Alice" .
# It holds because the following instance of the rule body is provable:
#   :alice a :Adult .
#   :alice :name "Alice" .
#   ?_b1 time:localTime "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime .
#   (:alice) log:skolem genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 .
#   ("Brew Club card for " "Alice") string:concatenation "Brew Club card for Alice" .
# via the schematic forward rule:
#   {
#     ?p a :Adult .
#     ?p :name ?name .
#     ?_b1 time:localTime ?now .
#     (?p) log:skolem ?card .
#     ("Brew Club card for " ?name) string:concatenation ?label .
#   } => {
#     ?card a :MembershipCard .
#     ?card :holder ?p .
#     ?card :issuedAt ?now .
#     ?card rdfs:label ?label .
#   } .
# with substitution (on rule variables):
#   ?card = genid:9e06e026-ada3-9430-3e11-8dd8c37dac24
#   ?label = "Brew Club card for Alice"
#   ?name = "Alice"
#   ?now = "2025-12-19T23:53:14.784+01:00"^^xsd:dateTime
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:9e06e026-ada3-9430-3e11-8dd8c37dac24 rdfs:label "Brew Club card for Alice" .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :order1 :eligibleDiscount true .
# It holds because the following instance of the rule body is provable:
#   :order1 a :Order .
#   :order1 a :BigOrder .
#   :order1 :by :alice .
#   :alice a :Adult .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o a :BigOrder .
#     ?o :by ?p .
#     ?p a :Adult .
#   } => {
#     ?o :eligibleDiscount true .
#   } .
# with substitution (on rule variables):
#   ?o = :order1
#   ?p = :alice
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:order1 :eligibleDiscount true .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:fbd10997-9fd6-99ce-fa19-a82424656d08 a :Receipt .
# It holds because the following instance of the rule body is provable:
#   :order2 a :Order .
#   :order2 :id "ORD-2025-002" .
#   ("ORD-2025-002") log:skolem genid:fbd10997-9fd6-99ce-fa19-a82424656d08 .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o :id ?id .
#     (?id) log:skolem ?receipt .
#   } => {
#     ?receipt a :Receipt .
#     ?receipt :forOrder ?o .
#     ?receipt :receiptId ?id .
#   } .
# with substitution (on rule variables):
#   ?id = "ORD-2025-002"
#   ?o = :order2
#   ?receipt = genid:fbd10997-9fd6-99ce-fa19-a82424656d08
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:fbd10997-9fd6-99ce-fa19-a82424656d08 a :Receipt .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:fbd10997-9fd6-99ce-fa19-a82424656d08 :forOrder :order2 .
# It holds because the following instance of the rule body is provable:
#   :order2 a :Order .
#   :order2 :id "ORD-2025-002" .
#   ("ORD-2025-002") log:skolem genid:fbd10997-9fd6-99ce-fa19-a82424656d08 .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o :id ?id .
#     (?id) log:skolem ?receipt .
#   } => {
#     ?receipt a :Receipt .
#     ?receipt :forOrder ?o .
#     ?receipt :receiptId ?id .
#   } .
# with substitution (on rule variables):
#   ?id = "ORD-2025-002"
#   ?o = :order2
#   ?receipt = genid:fbd10997-9fd6-99ce-fa19-a82424656d08
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:fbd10997-9fd6-99ce-fa19-a82424656d08 :forOrder :order2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:fbd10997-9fd6-99ce-fa19-a82424656d08 :receiptId "ORD-2025-002" .
# It holds because the following instance of the rule body is provable:
#   :order2 a :Order .
#   :order2 :id "ORD-2025-002" .
#   ("ORD-2025-002") log:skolem genid:fbd10997-9fd6-99ce-fa19-a82424656d08 .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o :id ?id .
#     (?id) log:skolem ?receipt .
#   } => {
#     ?receipt a :Receipt .
#     ?receipt :forOrder ?o .
#     ?receipt :receiptId ?id .
#   } .
# with substitution (on rule variables):
#   ?id = "ORD-2025-002"
#   ?o = :order2
#   ?receipt = genid:fbd10997-9fd6-99ce-fa19-a82424656d08
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:fbd10997-9fd6-99ce-fa19-a82424656d08 :receiptId "ORD-2025-002" .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 a :Receipt .
# It holds because the following instance of the rule body is provable:
#   :order1 a :Order .
#   :order1 :id "ORD-2025-001" .
#   ("ORD-2025-001") log:skolem genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o :id ?id .
#     (?id) log:skolem ?receipt .
#   } => {
#     ?receipt a :Receipt .
#     ?receipt :forOrder ?o .
#     ?receipt :receiptId ?id .
#   } .
# with substitution (on rule variables):
#   ?id = "ORD-2025-001"
#   ?o = :order1
#   ?receipt = genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 a :Receipt .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 :forOrder :order1 .
# It holds because the following instance of the rule body is provable:
#   :order1 a :Order .
#   :order1 :id "ORD-2025-001" .
#   ("ORD-2025-001") log:skolem genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o :id ?id .
#     (?id) log:skolem ?receipt .
#   } => {
#     ?receipt a :Receipt .
#     ?receipt :forOrder ?o .
#     ?receipt :receiptId ?id .
#   } .
# with substitution (on rule variables):
#   ?id = "ORD-2025-001"
#   ?o = :order1
#   ?receipt = genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 :forOrder :order1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 :receiptId "ORD-2025-001" .
# It holds because the following instance of the rule body is provable:
#   :order1 a :Order .
#   :order1 :id "ORD-2025-001" .
#   ("ORD-2025-001") log:skolem genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 .
# via the schematic forward rule:
#   {
#     ?o a :Order .
#     ?o :id ?id .
#     (?id) log:skolem ?receipt .
#   } => {
#     ?receipt a :Receipt .
#     ?receipt :forOrder ?o .
#     ?receipt :receiptId ?id .
#   } .
# with substitution (on rule variables):
#   ?id = "ORD-2025-001"
#   ?o = :order1
#   ?receipt = genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

genid:35d6c1c8-ee0c-5a7a-8ec2-654c5e1b34b4 :receiptId "ORD-2025-001" .

