@prefix : <http://example.org/cranberry-calculus#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :DataSet1 :mean 2.642857142857143 .
# It holds because the following instance of the rule body is provable:
#   :DataSet1 :values (1.2 1.3 1.4 1.25 1.35 2.0 10.0) .
#   :DataSet1 :zThreshold 2.0 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:length 7 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) math:sum 18.5 .
#   (18.5 7) math:quotient 2.642857142857143 .
#   (?sq {
#       (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:member ?x .
#       (?x 2.642857142857143) math:difference ?d .
#       (?d 2.0) math:exponentiation ?sq .
#   } (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773)) log:collectAllIn ?_b1 .
#   (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773) math:sum 63.58214285714286 .
#   (63.58214285714286 7) math:quotient 9.083163265306123 .
#   (9.083163265306123 0.5) math:exponentiation 3.0138286721886036 .
# via the schematic forward rule:
#   {
#     :DataSet1 :values ?xs .
#     :DataSet1 :zThreshold ?thr .
#     ?xs list:length ?n .
#     ?xs math:sum ?sum .
#     (?sum ?n) math:quotient ?mean .
#     (?sq {
#         ?xs list:member ?x .
#         (?x ?mean) math:difference ?d .
#         (?d 2.0) math:exponentiation ?sq .
#     } ?sqList) log:collectAllIn ?_b1 .
#     ?sqList math:sum ?sse .
#     (?sse ?n) math:quotient ?var .
#     (?var 0.5) math:exponentiation ?std .
#   } => {
#     :DataSet1 :mean ?mean .
#     :DataSet1 :variance ?var .
#     :DataSet1 :stddev ?std .
#   } .
# with substitution (on rule variables):
#   ?mean = 2.642857142857143
#   ?n = 7
#   ?sqList = (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773)
#   ?sse = 63.58214285714286
#   ?std = 3.0138286721886036
#   ?sum = 18.5
#   ?thr = 2.0
#   ?var = 9.083163265306123
#   ?xs = (1.2 1.3 1.4 1.25 1.35 2.0 10.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:DataSet1 :mean 2.642857142857143 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :DataSet1 :variance 9.083163265306123 .
# It holds because the following instance of the rule body is provable:
#   :DataSet1 :values (1.2 1.3 1.4 1.25 1.35 2.0 10.0) .
#   :DataSet1 :zThreshold 2.0 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:length 7 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) math:sum 18.5 .
#   (18.5 7) math:quotient 2.642857142857143 .
#   (?sq {
#       (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:member ?x .
#       (?x 2.642857142857143) math:difference ?d .
#       (?d 2.0) math:exponentiation ?sq .
#   } (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773)) log:collectAllIn ?_b1 .
#   (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773) math:sum 63.58214285714286 .
#   (63.58214285714286 7) math:quotient 9.083163265306123 .
#   (9.083163265306123 0.5) math:exponentiation 3.0138286721886036 .
# via the schematic forward rule:
#   {
#     :DataSet1 :values ?xs .
#     :DataSet1 :zThreshold ?thr .
#     ?xs list:length ?n .
#     ?xs math:sum ?sum .
#     (?sum ?n) math:quotient ?mean .
#     (?sq {
#         ?xs list:member ?x .
#         (?x ?mean) math:difference ?d .
#         (?d 2.0) math:exponentiation ?sq .
#     } ?sqList) log:collectAllIn ?_b1 .
#     ?sqList math:sum ?sse .
#     (?sse ?n) math:quotient ?var .
#     (?var 0.5) math:exponentiation ?std .
#   } => {
#     :DataSet1 :mean ?mean .
#     :DataSet1 :variance ?var .
#     :DataSet1 :stddev ?std .
#   } .
# with substitution (on rule variables):
#   ?mean = 2.642857142857143
#   ?n = 7
#   ?sqList = (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773)
#   ?sse = 63.58214285714286
#   ?std = 3.0138286721886036
#   ?sum = 18.5
#   ?thr = 2.0
#   ?var = 9.083163265306123
#   ?xs = (1.2 1.3 1.4 1.25 1.35 2.0 10.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:DataSet1 :variance 9.083163265306123 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :DataSet1 :stddev 3.0138286721886036 .
# It holds because the following instance of the rule body is provable:
#   :DataSet1 :values (1.2 1.3 1.4 1.25 1.35 2.0 10.0) .
#   :DataSet1 :zThreshold 2.0 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:length 7 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) math:sum 18.5 .
#   (18.5 7) math:quotient 2.642857142857143 .
#   (?sq {
#       (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:member ?x .
#       (?x 2.642857142857143) math:difference ?d .
#       (?d 2.0) math:exponentiation ?sq .
#   } (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773)) log:collectAllIn ?_b1 .
#   (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773) math:sum 63.58214285714286 .
#   (63.58214285714286 7) math:quotient 9.083163265306123 .
#   (9.083163265306123 0.5) math:exponentiation 3.0138286721886036 .
# via the schematic forward rule:
#   {
#     :DataSet1 :values ?xs .
#     :DataSet1 :zThreshold ?thr .
#     ?xs list:length ?n .
#     ?xs math:sum ?sum .
#     (?sum ?n) math:quotient ?mean .
#     (?sq {
#         ?xs list:member ?x .
#         (?x ?mean) math:difference ?d .
#         (?d 2.0) math:exponentiation ?sq .
#     } ?sqList) log:collectAllIn ?_b1 .
#     ?sqList math:sum ?sse .
#     (?sse ?n) math:quotient ?var .
#     (?var 0.5) math:exponentiation ?std .
#   } => {
#     :DataSet1 :mean ?mean .
#     :DataSet1 :variance ?var .
#     :DataSet1 :stddev ?std .
#   } .
# with substitution (on rule variables):
#   ?mean = 2.642857142857143
#   ?n = 7
#   ?sqList = (54.12755102040817 0.4132653061224489 1.6714795918367342 1.9400510204081631 1.5446938775510204 1.8032653061224486 2.0818367346938773)
#   ?sse = 63.58214285714286
#   ?std = 3.0138286721886036
#   ?sum = 18.5
#   ?thr = 2.0
#   ?var = 9.083163265306123
#   ?xs = (1.2 1.3 1.4 1.25 1.35 2.0 10.0)
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:DataSet1 :stddev 3.0138286721886036 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :value 10.0 .
# It holds because the following instance of the rule body is provable:
#   :DataSet1 :values (1.2 1.3 1.4 1.25 1.35 2.0 10.0) .
#   :DataSet1 :mean 2.642857142857143 .
#   :DataSet1 :stddev 3.0138286721886036 .
#   :DataSet1 :zThreshold 2.0 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:member 10.0 .
#   (10.0 2.642857142857143) math:difference 7.357142857142858 .
#   (7.357142857142858 3.0138286721886036) math:quotient 2.44112843076783 .
#   2.44112843076783 math:absoluteValue 2.44112843076783 .
#   2.44112843076783 math:greaterThan 2.0 .
# via the schematic forward rule:
#   {
#     :DataSet1 :values ?xs .
#     :DataSet1 :mean ?mean .
#     :DataSet1 :stddev ?std .
#     :DataSet1 :zThreshold ?thr .
#     ?xs list:member ?x .
#     (?x ?mean) math:difference ?d .
#     (?d ?std) math:quotient ?z .
#     ?z math:absoluteValue ?absz .
#     ?absz math:greaterThan ?thr .
#   } => {
#     _:b1 :value ?x .
#     _:b1 :zScore ?z .
#     :DataSet1 :outlier _:b1 .
#   } .
# with substitution (on rule variables):
#   ?absz = 2.44112843076783
#   ?d = 7.357142857142858
#   ?mean = 2.642857142857143
#   ?std = 3.0138286721886036
#   ?thr = 2.0
#   ?x = 10.0
#   ?xs = (1.2 1.3 1.4 1.25 1.35 2.0 10.0)
#   ?z = 2.44112843076783
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :value 10.0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_0 :zScore 2.44112843076783 .
# It holds because the following instance of the rule body is provable:
#   :DataSet1 :values (1.2 1.3 1.4 1.25 1.35 2.0 10.0) .
#   :DataSet1 :mean 2.642857142857143 .
#   :DataSet1 :stddev 3.0138286721886036 .
#   :DataSet1 :zThreshold 2.0 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:member 10.0 .
#   (10.0 2.642857142857143) math:difference 7.357142857142858 .
#   (7.357142857142858 3.0138286721886036) math:quotient 2.44112843076783 .
#   2.44112843076783 math:absoluteValue 2.44112843076783 .
#   2.44112843076783 math:greaterThan 2.0 .
# via the schematic forward rule:
#   {
#     :DataSet1 :values ?xs .
#     :DataSet1 :mean ?mean .
#     :DataSet1 :stddev ?std .
#     :DataSet1 :zThreshold ?thr .
#     ?xs list:member ?x .
#     (?x ?mean) math:difference ?d .
#     (?d ?std) math:quotient ?z .
#     ?z math:absoluteValue ?absz .
#     ?absz math:greaterThan ?thr .
#   } => {
#     _:b1 :value ?x .
#     _:b1 :zScore ?z .
#     :DataSet1 :outlier _:b1 .
#   } .
# with substitution (on rule variables):
#   ?absz = 2.44112843076783
#   ?d = 7.357142857142858
#   ?mean = 2.642857142857143
#   ?std = 3.0138286721886036
#   ?thr = 2.0
#   ?x = 10.0
#   ?xs = (1.2 1.3 1.4 1.25 1.35 2.0 10.0)
#   ?z = 2.44112843076783
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_0 :zScore 2.44112843076783 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :DataSet1 :outlier _:sk_0 .
# It holds because the following instance of the rule body is provable:
#   :DataSet1 :values (1.2 1.3 1.4 1.25 1.35 2.0 10.0) .
#   :DataSet1 :mean 2.642857142857143 .
#   :DataSet1 :stddev 3.0138286721886036 .
#   :DataSet1 :zThreshold 2.0 .
#   (1.2 1.3 1.4 1.25 1.35 2.0 10.0) list:member 10.0 .
#   (10.0 2.642857142857143) math:difference 7.357142857142858 .
#   (7.357142857142858 3.0138286721886036) math:quotient 2.44112843076783 .
#   2.44112843076783 math:absoluteValue 2.44112843076783 .
#   2.44112843076783 math:greaterThan 2.0 .
# via the schematic forward rule:
#   {
#     :DataSet1 :values ?xs .
#     :DataSet1 :mean ?mean .
#     :DataSet1 :stddev ?std .
#     :DataSet1 :zThreshold ?thr .
#     ?xs list:member ?x .
#     (?x ?mean) math:difference ?d .
#     (?d ?std) math:quotient ?z .
#     ?z math:absoluteValue ?absz .
#     ?absz math:greaterThan ?thr .
#   } => {
#     _:b1 :value ?x .
#     _:b1 :zScore ?z .
#     :DataSet1 :outlier _:b1 .
#   } .
# with substitution (on rule variables):
#   ?absz = 2.44112843076783
#   ?d = 7.357142857142858
#   ?mean = 2.642857142857143
#   ?std = 3.0138286721886036
#   ?thr = 2.0
#   ?x = 10.0
#   ?xs = (1.2 1.3 1.4 1.25 1.35 2.0 10.0)
#   ?z = 2.44112843076783
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:DataSet1 :outlier _:sk_0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :VecA :dotWithVecB 12 .
# It holds because the following instance of the rule body is provable:
#   :VecA :x 3.0 .
#   :VecA :y 4.0 .
#   :VecB :x 4.0 .
#   :VecB :y 0.0 .
#   (3.0 4.0) math:product 12 .
#   (4.0 0.0) math:product 0 .
#   (12 0) math:sum 12 .
#   (3.0 2.0) math:exponentiation 9 .
#   (4.0 2.0) math:exponentiation 16 .
#   (9 16) math:sum 25 .
#   (25 0.5) math:exponentiation 5 .
#   (4.0 2.0) math:exponentiation 16 .
#   (0.0 2.0) math:exponentiation 0 .
#   (16 0) math:sum 16 .
#   (16 0.5) math:exponentiation 4 .
#   (5 4) math:product 20 .
#   (12 20) math:quotient 0.6 .
#   0.6 math:acos 0.9272952180016123 .
#   0.9272952180016123 math:degrees 53.13010235415598 .
# via the schematic forward rule:
#   {
#     :VecA :x ?ax .
#     :VecA :y ?ay .
#     :VecB :x ?bx .
#     :VecB :y ?by .
#     (?ax ?bx) math:product ?axbx .
#     (?ay ?by) math:product ?ayby .
#     (?axbx ?ayby) math:sum ?dot .
#     (?ax 2.0) math:exponentiation ?ax2 .
#     (?ay 2.0) math:exponentiation ?ay2 .
#     (?ax2 ?ay2) math:sum ?a2 .
#     (?a2 0.5) math:exponentiation ?aNorm .
#     (?bx 2.0) math:exponentiation ?bx2 .
#     (?by 2.0) math:exponentiation ?by2 .
#     (?bx2 ?by2) math:sum ?b2 .
#     (?b2 0.5) math:exponentiation ?bNorm .
#     (?aNorm ?bNorm) math:product ?den .
#     (?dot ?den) math:quotient ?cosTheta .
#     ?cosTheta math:acos ?thetaRad .
#     ?thetaRad math:degrees ?thetaDeg .
#   } => {
#     :VecA :dotWithVecB ?dot .
#     _:b2 :radians ?thetaRad .
#     _:b2 :degrees ?thetaDeg .
#     :VecA :angleToVecB _:b2 .
#   } .
# with substitution (on rule variables):
#   ?a2 = 25
#   ?aNorm = 5
#   ?ax = 3.0
#   ?ax2 = 9
#   ?axbx = 12
#   ?ay = 4.0
#   ?ay2 = 16
#   ?ayby = 0
#   ?b2 = 16
#   ?bNorm = 4
#   ?bx = 4.0
#   ?bx2 = 16
#   ?by = 0.0
#   ?by2 = 0
#   ?cosTheta = 0.6
#   ?den = 20
#   ?dot = 12
#   ?thetaDeg = 53.13010235415598
#   ?thetaRad = 0.9272952180016123
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:VecA :dotWithVecB 12 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :radians 0.9272952180016123 .
# It holds because the following instance of the rule body is provable:
#   :VecA :x 3.0 .
#   :VecA :y 4.0 .
#   :VecB :x 4.0 .
#   :VecB :y 0.0 .
#   (3.0 4.0) math:product 12 .
#   (4.0 0.0) math:product 0 .
#   (12 0) math:sum 12 .
#   (3.0 2.0) math:exponentiation 9 .
#   (4.0 2.0) math:exponentiation 16 .
#   (9 16) math:sum 25 .
#   (25 0.5) math:exponentiation 5 .
#   (4.0 2.0) math:exponentiation 16 .
#   (0.0 2.0) math:exponentiation 0 .
#   (16 0) math:sum 16 .
#   (16 0.5) math:exponentiation 4 .
#   (5 4) math:product 20 .
#   (12 20) math:quotient 0.6 .
#   0.6 math:acos 0.9272952180016123 .
#   0.9272952180016123 math:degrees 53.13010235415598 .
# via the schematic forward rule:
#   {
#     :VecA :x ?ax .
#     :VecA :y ?ay .
#     :VecB :x ?bx .
#     :VecB :y ?by .
#     (?ax ?bx) math:product ?axbx .
#     (?ay ?by) math:product ?ayby .
#     (?axbx ?ayby) math:sum ?dot .
#     (?ax 2.0) math:exponentiation ?ax2 .
#     (?ay 2.0) math:exponentiation ?ay2 .
#     (?ax2 ?ay2) math:sum ?a2 .
#     (?a2 0.5) math:exponentiation ?aNorm .
#     (?bx 2.0) math:exponentiation ?bx2 .
#     (?by 2.0) math:exponentiation ?by2 .
#     (?bx2 ?by2) math:sum ?b2 .
#     (?b2 0.5) math:exponentiation ?bNorm .
#     (?aNorm ?bNorm) math:product ?den .
#     (?dot ?den) math:quotient ?cosTheta .
#     ?cosTheta math:acos ?thetaRad .
#     ?thetaRad math:degrees ?thetaDeg .
#   } => {
#     :VecA :dotWithVecB ?dot .
#     _:b2 :radians ?thetaRad .
#     _:b2 :degrees ?thetaDeg .
#     :VecA :angleToVecB _:b2 .
#   } .
# with substitution (on rule variables):
#   ?a2 = 25
#   ?aNorm = 5
#   ?ax = 3.0
#   ?ax2 = 9
#   ?axbx = 12
#   ?ay = 4.0
#   ?ay2 = 16
#   ?ayby = 0
#   ?b2 = 16
#   ?bNorm = 4
#   ?bx = 4.0
#   ?bx2 = 16
#   ?by = 0.0
#   ?by2 = 0
#   ?cosTheta = 0.6
#   ?den = 20
#   ?dot = 12
#   ?thetaDeg = 53.13010235415598
#   ?thetaRad = 0.9272952180016123
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :radians 0.9272952180016123 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_1 :degrees 53.13010235415598 .
# It holds because the following instance of the rule body is provable:
#   :VecA :x 3.0 .
#   :VecA :y 4.0 .
#   :VecB :x 4.0 .
#   :VecB :y 0.0 .
#   (3.0 4.0) math:product 12 .
#   (4.0 0.0) math:product 0 .
#   (12 0) math:sum 12 .
#   (3.0 2.0) math:exponentiation 9 .
#   (4.0 2.0) math:exponentiation 16 .
#   (9 16) math:sum 25 .
#   (25 0.5) math:exponentiation 5 .
#   (4.0 2.0) math:exponentiation 16 .
#   (0.0 2.0) math:exponentiation 0 .
#   (16 0) math:sum 16 .
#   (16 0.5) math:exponentiation 4 .
#   (5 4) math:product 20 .
#   (12 20) math:quotient 0.6 .
#   0.6 math:acos 0.9272952180016123 .
#   0.9272952180016123 math:degrees 53.13010235415598 .
# via the schematic forward rule:
#   {
#     :VecA :x ?ax .
#     :VecA :y ?ay .
#     :VecB :x ?bx .
#     :VecB :y ?by .
#     (?ax ?bx) math:product ?axbx .
#     (?ay ?by) math:product ?ayby .
#     (?axbx ?ayby) math:sum ?dot .
#     (?ax 2.0) math:exponentiation ?ax2 .
#     (?ay 2.0) math:exponentiation ?ay2 .
#     (?ax2 ?ay2) math:sum ?a2 .
#     (?a2 0.5) math:exponentiation ?aNorm .
#     (?bx 2.0) math:exponentiation ?bx2 .
#     (?by 2.0) math:exponentiation ?by2 .
#     (?bx2 ?by2) math:sum ?b2 .
#     (?b2 0.5) math:exponentiation ?bNorm .
#     (?aNorm ?bNorm) math:product ?den .
#     (?dot ?den) math:quotient ?cosTheta .
#     ?cosTheta math:acos ?thetaRad .
#     ?thetaRad math:degrees ?thetaDeg .
#   } => {
#     :VecA :dotWithVecB ?dot .
#     _:b2 :radians ?thetaRad .
#     _:b2 :degrees ?thetaDeg .
#     :VecA :angleToVecB _:b2 .
#   } .
# with substitution (on rule variables):
#   ?a2 = 25
#   ?aNorm = 5
#   ?ax = 3.0
#   ?ax2 = 9
#   ?axbx = 12
#   ?ay = 4.0
#   ?ay2 = 16
#   ?ayby = 0
#   ?b2 = 16
#   ?bNorm = 4
#   ?bx = 4.0
#   ?bx2 = 16
#   ?by = 0.0
#   ?by2 = 0
#   ?cosTheta = 0.6
#   ?den = 20
#   ?dot = 12
#   ?thetaDeg = 53.13010235415598
#   ?thetaRad = 0.9272952180016123
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_1 :degrees 53.13010235415598 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :VecA :angleToVecB _:sk_1 .
# It holds because the following instance of the rule body is provable:
#   :VecA :x 3.0 .
#   :VecA :y 4.0 .
#   :VecB :x 4.0 .
#   :VecB :y 0.0 .
#   (3.0 4.0) math:product 12 .
#   (4.0 0.0) math:product 0 .
#   (12 0) math:sum 12 .
#   (3.0 2.0) math:exponentiation 9 .
#   (4.0 2.0) math:exponentiation 16 .
#   (9 16) math:sum 25 .
#   (25 0.5) math:exponentiation 5 .
#   (4.0 2.0) math:exponentiation 16 .
#   (0.0 2.0) math:exponentiation 0 .
#   (16 0) math:sum 16 .
#   (16 0.5) math:exponentiation 4 .
#   (5 4) math:product 20 .
#   (12 20) math:quotient 0.6 .
#   0.6 math:acos 0.9272952180016123 .
#   0.9272952180016123 math:degrees 53.13010235415598 .
# via the schematic forward rule:
#   {
#     :VecA :x ?ax .
#     :VecA :y ?ay .
#     :VecB :x ?bx .
#     :VecB :y ?by .
#     (?ax ?bx) math:product ?axbx .
#     (?ay ?by) math:product ?ayby .
#     (?axbx ?ayby) math:sum ?dot .
#     (?ax 2.0) math:exponentiation ?ax2 .
#     (?ay 2.0) math:exponentiation ?ay2 .
#     (?ax2 ?ay2) math:sum ?a2 .
#     (?a2 0.5) math:exponentiation ?aNorm .
#     (?bx 2.0) math:exponentiation ?bx2 .
#     (?by 2.0) math:exponentiation ?by2 .
#     (?bx2 ?by2) math:sum ?b2 .
#     (?b2 0.5) math:exponentiation ?bNorm .
#     (?aNorm ?bNorm) math:product ?den .
#     (?dot ?den) math:quotient ?cosTheta .
#     ?cosTheta math:acos ?thetaRad .
#     ?thetaRad math:degrees ?thetaDeg .
#   } => {
#     :VecA :dotWithVecB ?dot .
#     _:b2 :radians ?thetaRad .
#     _:b2 :degrees ?thetaDeg .
#     :VecA :angleToVecB _:b2 .
#   } .
# with substitution (on rule variables):
#   ?a2 = 25
#   ?aNorm = 5
#   ?ax = 3.0
#   ?ax2 = 9
#   ?axbx = 12
#   ?ay = 4.0
#   ?ay2 = 16
#   ?ayby = 0
#   ?b2 = 16
#   ?bNorm = 4
#   ?bx = 4.0
#   ?bx2 = 16
#   ?by = 0.0
#   ?by2 = 0
#   ?cosTheta = 0.6
#   ?den = 20
#   ?dot = 12
#   ?thetaDeg = 53.13010235415598
#   ?thetaRad = 0.9272952180016123
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:VecA :angleToVecB _:sk_1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Shot1 :vx 21.213203435596427 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Shot1 :vx 21.213203435596427 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Shot1 :vy 21.213203435596423 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Shot1 :vy 21.213203435596423 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Shot1 :timeOfFlight 4.324812117348913 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Shot1 :timeOfFlight 4.324812117348913 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Shot1 :range 91.74311926605502 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Shot1 :range 91.74311926605502 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Shot1 :maxHeight 22.935779816513755 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Shot1 :maxHeight 22.935779816513755 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :t 2.5 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :t 2.5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :x 53.033008588991066 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :x 53.033008588991066 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   _:sk_2 :y 22.37675858899106 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

_:sk_2 :y 22.37675858899106 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :Shot1 :positionAtSample _:sk_2 .
# It holds because the following instance of the rule body is provable:
#   :Shot1 :speed 30.0 .
#   :Shot1 :angleRad 0.7853981633974483 .
#   :Shot1 :g 9.81 .
#   :Shot1 :tSample 2.5 .
#   0.7853981633974483 math:sin 0.7071067811865475 .
#   0.7853981633974483 math:cos 0.7071067811865476 .
#   (30.0 0.7071067811865476) math:product 21.213203435596427 .
#   (30.0 0.7071067811865475) math:product 21.213203435596423 .
#   (2.0 21.213203435596423) math:product 42.426406871192846 .
#   (42.426406871192846 9.81) math:quotient 4.324812117348913 .
#   (21.213203435596427 4.324812117348913) math:product 91.74311926605502 .
#   (21.213203435596423 2.0) math:exponentiation 449.9999999999999 .
#   (2.0 9.81) math:product 19.62 .
#   (449.9999999999999 19.62) math:quotient 22.935779816513755 .
#   (21.213203435596427 2.5) math:product 53.033008588991066 .
#   (21.213203435596423 2.5) math:product 53.03300858899106 .
#   (2.5 2.0) math:exponentiation 6.25 .
#   (9.81 6.25) math:product 61.3125 .
#   (0.5 61.3125) math:product 30.65625 .
#   (53.03300858899106 30.65625) math:difference 22.37675858899106 .
# via the schematic forward rule:
#   {
#     :Shot1 :speed ?v .
#     :Shot1 :angleRad ?theta .
#     :Shot1 :g ?g .
#     :Shot1 :tSample ?t .
#     ?theta math:sin ?sinT .
#     ?theta math:cos ?cosT .
#     (?v ?cosT) math:product ?vx .
#     (?v ?sinT) math:product ?vy .
#     (2.0 ?vy) math:product ?twoVy .
#     (?twoVy ?g) math:quotient ?tFlight .
#     (?vx ?tFlight) math:product ?range .
#     (?vy 2.0) math:exponentiation ?vy2 .
#     (2.0 ?g) math:product ?twoG .
#     (?vy2 ?twoG) math:quotient ?hMax .
#     (?vx ?t) math:product ?xAtT .
#     (?vy ?t) math:product ?vy_t .
#     (?t 2.0) math:exponentiation ?t2 .
#     (?g ?t2) math:product ?g_t2 .
#     (0.5 ?g_t2) math:product ?half_g_t2 .
#     (?vy_t ?half_g_t2) math:difference ?yAtT .
#   } => {
#     :Shot1 :vx ?vx .
#     :Shot1 :vy ?vy .
#     :Shot1 :timeOfFlight ?tFlight .
#     :Shot1 :range ?range .
#     :Shot1 :maxHeight ?hMax .
#     _:b3 :t ?t .
#     _:b3 :x ?xAtT .
#     _:b3 :y ?yAtT .
#     :Shot1 :positionAtSample _:b3 .
#   } .
# with substitution (on rule variables):
#   ?cosT = 0.7071067811865476
#   ?g = 9.81
#   ?g_t2 = 61.3125
#   ?hMax = 22.935779816513755
#   ?half_g_t2 = 30.65625
#   ?range = 91.74311926605502
#   ?sinT = 0.7071067811865475
#   ?t = 2.5
#   ?t2 = 6.25
#   ?tFlight = 4.324812117348913
#   ?theta = 0.7853981633974483
#   ?twoG = 19.62
#   ?twoVy = 42.426406871192846
#   ?v = 30.0
#   ?vx = 21.213203435596427
#   ?vy = 21.213203435596423
#   ?vy2 = 449.9999999999999
#   ?vy_t = 53.03300858899106
#   ?xAtT = 53.033008588991066
#   ?yAtT = 22.37675858899106
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:Shot1 :positionAtSample _:sk_2 .

