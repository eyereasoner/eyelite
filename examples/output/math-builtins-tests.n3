@prefix : <http://example.org/math-tests#> .
@prefix math: <http://www.w3.org/2000/10/swap/math#> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   -2 math:absoluteValue 2 .
#   2 math:equalTo 2 .
# via the schematic forward rule:
#   {
#     -2 math:absoluteValue ?abs .
#     ?abs math:equalTo 2 .
#   } => {
#     :test-absoluteValue-1 a :MathBuiltinTest .
#     :test-absoluteValue-1 :builtin math:absoluteValue .
#     :test-absoluteValue-1 :input -2 .
#     :test-absoluteValue-1 :expected 2 .
#     :test-absoluteValue-1 :actual ?abs .
#     :test-absoluteValue-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-1 :builtin math:absoluteValue .
# It holds because the following instance of the rule body is provable:
#   -2 math:absoluteValue 2 .
#   2 math:equalTo 2 .
# via the schematic forward rule:
#   {
#     -2 math:absoluteValue ?abs .
#     ?abs math:equalTo 2 .
#   } => {
#     :test-absoluteValue-1 a :MathBuiltinTest .
#     :test-absoluteValue-1 :builtin math:absoluteValue .
#     :test-absoluteValue-1 :input -2 .
#     :test-absoluteValue-1 :expected 2 .
#     :test-absoluteValue-1 :actual ?abs .
#     :test-absoluteValue-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-1 :builtin math:absoluteValue .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-1 :input -2 .
# It holds because the following instance of the rule body is provable:
#   -2 math:absoluteValue 2 .
#   2 math:equalTo 2 .
# via the schematic forward rule:
#   {
#     -2 math:absoluteValue ?abs .
#     ?abs math:equalTo 2 .
#   } => {
#     :test-absoluteValue-1 a :MathBuiltinTest .
#     :test-absoluteValue-1 :builtin math:absoluteValue .
#     :test-absoluteValue-1 :input -2 .
#     :test-absoluteValue-1 :expected 2 .
#     :test-absoluteValue-1 :actual ?abs .
#     :test-absoluteValue-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-1 :input -2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-1 :expected 2 .
# It holds because the following instance of the rule body is provable:
#   -2 math:absoluteValue 2 .
#   2 math:equalTo 2 .
# via the schematic forward rule:
#   {
#     -2 math:absoluteValue ?abs .
#     ?abs math:equalTo 2 .
#   } => {
#     :test-absoluteValue-1 a :MathBuiltinTest .
#     :test-absoluteValue-1 :builtin math:absoluteValue .
#     :test-absoluteValue-1 :input -2 .
#     :test-absoluteValue-1 :expected 2 .
#     :test-absoluteValue-1 :actual ?abs .
#     :test-absoluteValue-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-1 :expected 2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-1 :actual 2 .
# It holds because the following instance of the rule body is provable:
#   -2 math:absoluteValue 2 .
#   2 math:equalTo 2 .
# via the schematic forward rule:
#   {
#     -2 math:absoluteValue ?abs .
#     ?abs math:equalTo 2 .
#   } => {
#     :test-absoluteValue-1 a :MathBuiltinTest .
#     :test-absoluteValue-1 :builtin math:absoluteValue .
#     :test-absoluteValue-1 :input -2 .
#     :test-absoluteValue-1 :expected 2 .
#     :test-absoluteValue-1 :actual ?abs .
#     :test-absoluteValue-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-1 :actual 2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   -2 math:absoluteValue 2 .
#   2 math:equalTo 2 .
# via the schematic forward rule:
#   {
#     -2 math:absoluteValue ?abs .
#     ?abs math:equalTo 2 .
#   } => {
#     :test-absoluteValue-1 a :MathBuiltinTest .
#     :test-absoluteValue-1 :builtin math:absoluteValue .
#     :test-absoluteValue-1 :input -2 .
#     :test-absoluteValue-1 :expected 2 .
#     :test-absoluteValue-1 :actual ?abs .
#     :test-absoluteValue-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-2 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   3 math:absoluteValue 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     3 math:absoluteValue ?abs .
#     ?abs math:equalTo 3 .
#   } => {
#     :test-absoluteValue-2 a :MathBuiltinTest .
#     :test-absoluteValue-2 :builtin math:absoluteValue .
#     :test-absoluteValue-2 :input 3 .
#     :test-absoluteValue-2 :expected 3 .
#     :test-absoluteValue-2 :actual ?abs .
#     :test-absoluteValue-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-2 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-2 :builtin math:absoluteValue .
# It holds because the following instance of the rule body is provable:
#   3 math:absoluteValue 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     3 math:absoluteValue ?abs .
#     ?abs math:equalTo 3 .
#   } => {
#     :test-absoluteValue-2 a :MathBuiltinTest .
#     :test-absoluteValue-2 :builtin math:absoluteValue .
#     :test-absoluteValue-2 :input 3 .
#     :test-absoluteValue-2 :expected 3 .
#     :test-absoluteValue-2 :actual ?abs .
#     :test-absoluteValue-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-2 :builtin math:absoluteValue .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-2 :input 3 .
# It holds because the following instance of the rule body is provable:
#   3 math:absoluteValue 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     3 math:absoluteValue ?abs .
#     ?abs math:equalTo 3 .
#   } => {
#     :test-absoluteValue-2 a :MathBuiltinTest .
#     :test-absoluteValue-2 :builtin math:absoluteValue .
#     :test-absoluteValue-2 :input 3 .
#     :test-absoluteValue-2 :expected 3 .
#     :test-absoluteValue-2 :actual ?abs .
#     :test-absoluteValue-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-2 :input 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-2 :expected 3 .
# It holds because the following instance of the rule body is provable:
#   3 math:absoluteValue 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     3 math:absoluteValue ?abs .
#     ?abs math:equalTo 3 .
#   } => {
#     :test-absoluteValue-2 a :MathBuiltinTest .
#     :test-absoluteValue-2 :builtin math:absoluteValue .
#     :test-absoluteValue-2 :input 3 .
#     :test-absoluteValue-2 :expected 3 .
#     :test-absoluteValue-2 :actual ?abs .
#     :test-absoluteValue-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-2 :expected 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-2 :actual 3 .
# It holds because the following instance of the rule body is provable:
#   3 math:absoluteValue 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     3 math:absoluteValue ?abs .
#     ?abs math:equalTo 3 .
#   } => {
#     :test-absoluteValue-2 a :MathBuiltinTest .
#     :test-absoluteValue-2 :builtin math:absoluteValue .
#     :test-absoluteValue-2 :input 3 .
#     :test-absoluteValue-2 :expected 3 .
#     :test-absoluteValue-2 :actual ?abs .
#     :test-absoluteValue-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-2 :actual 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-absoluteValue-2 :status :pass .
# It holds because the following instance of the rule body is provable:
#   3 math:absoluteValue 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     3 math:absoluteValue ?abs .
#     ?abs math:equalTo 3 .
#   } => {
#     :test-absoluteValue-2 a :MathBuiltinTest .
#     :test-absoluteValue-2 :builtin math:absoluteValue .
#     :test-absoluteValue-2 :input 3 .
#     :test-absoluteValue-2 :expected 3 .
#     :test-absoluteValue-2 :actual ?abs .
#     :test-absoluteValue-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?abs = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-absoluteValue-2 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-acos-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   1 math:acos 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     1 math:acos ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-acos-1 a :MathBuiltinTest .
#     :test-acos-1 :builtin math:acos .
#     :test-acos-1 :input 1 .
#     :test-acos-1 :expected 0 .
#     :test-acos-1 :actual ?r .
#     :test-acos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-acos-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-acos-1 :builtin math:acos .
# It holds because the following instance of the rule body is provable:
#   1 math:acos 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     1 math:acos ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-acos-1 a :MathBuiltinTest .
#     :test-acos-1 :builtin math:acos .
#     :test-acos-1 :input 1 .
#     :test-acos-1 :expected 0 .
#     :test-acos-1 :actual ?r .
#     :test-acos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-acos-1 :builtin math:acos .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-acos-1 :input 1 .
# It holds because the following instance of the rule body is provable:
#   1 math:acos 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     1 math:acos ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-acos-1 a :MathBuiltinTest .
#     :test-acos-1 :builtin math:acos .
#     :test-acos-1 :input 1 .
#     :test-acos-1 :expected 0 .
#     :test-acos-1 :actual ?r .
#     :test-acos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-acos-1 :input 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-acos-1 :expected 0 .
# It holds because the following instance of the rule body is provable:
#   1 math:acos 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     1 math:acos ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-acos-1 a :MathBuiltinTest .
#     :test-acos-1 :builtin math:acos .
#     :test-acos-1 :input 1 .
#     :test-acos-1 :expected 0 .
#     :test-acos-1 :actual ?r .
#     :test-acos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-acos-1 :expected 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-acos-1 :actual 0 .
# It holds because the following instance of the rule body is provable:
#   1 math:acos 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     1 math:acos ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-acos-1 a :MathBuiltinTest .
#     :test-acos-1 :builtin math:acos .
#     :test-acos-1 :input 1 .
#     :test-acos-1 :expected 0 .
#     :test-acos-1 :actual ?r .
#     :test-acos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-acos-1 :actual 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-acos-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   1 math:acos 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     1 math:acos ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-acos-1 a :MathBuiltinTest .
#     :test-acos-1 :builtin math:acos .
#     :test-acos-1 :input 1 .
#     :test-acos-1 :expected 0 .
#     :test-acos-1 :actual ?r .
#     :test-acos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-acos-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-asin-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:asin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:asin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-asin-1 a :MathBuiltinTest .
#     :test-asin-1 :builtin math:asin .
#     :test-asin-1 :input 0 .
#     :test-asin-1 :expected 0 .
#     :test-asin-1 :actual ?r .
#     :test-asin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-asin-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-asin-1 :builtin math:asin .
# It holds because the following instance of the rule body is provable:
#   0 math:asin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:asin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-asin-1 a :MathBuiltinTest .
#     :test-asin-1 :builtin math:asin .
#     :test-asin-1 :input 0 .
#     :test-asin-1 :expected 0 .
#     :test-asin-1 :actual ?r .
#     :test-asin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-asin-1 :builtin math:asin .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-asin-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:asin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:asin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-asin-1 a :MathBuiltinTest .
#     :test-asin-1 :builtin math:asin .
#     :test-asin-1 :input 0 .
#     :test-asin-1 :expected 0 .
#     :test-asin-1 :actual ?r .
#     :test-asin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-asin-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-asin-1 :expected 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:asin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:asin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-asin-1 a :MathBuiltinTest .
#     :test-asin-1 :builtin math:asin .
#     :test-asin-1 :input 0 .
#     :test-asin-1 :expected 0 .
#     :test-asin-1 :actual ?r .
#     :test-asin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-asin-1 :expected 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-asin-1 :actual 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:asin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:asin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-asin-1 a :MathBuiltinTest .
#     :test-asin-1 :builtin math:asin .
#     :test-asin-1 :input 0 .
#     :test-asin-1 :expected 0 .
#     :test-asin-1 :actual ?r .
#     :test-asin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-asin-1 :actual 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-asin-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:asin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:asin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-asin-1 a :MathBuiltinTest .
#     :test-asin-1 :builtin math:asin .
#     :test-asin-1 :input 0 .
#     :test-asin-1 :expected 0 .
#     :test-asin-1 :actual ?r .
#     :test-asin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-asin-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-atan-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   1 math:atan 0.7853981633974483 .
#   0.7853981633974483 math:equalTo 0.7853981633974483 .
# via the schematic forward rule:
#   {
#     1 math:atan ?r .
#     ?r math:equalTo 0.7853981633974483 .
#   } => {
#     :test-atan-1 a :MathBuiltinTest .
#     :test-atan-1 :builtin math:atan .
#     :test-atan-1 :input 1 .
#     :test-atan-1 :expected 0.7853981633974483 .
#     :test-atan-1 :actual ?r .
#     :test-atan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0.7853981633974483
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-atan-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-atan-1 :builtin math:atan .
# It holds because the following instance of the rule body is provable:
#   1 math:atan 0.7853981633974483 .
#   0.7853981633974483 math:equalTo 0.7853981633974483 .
# via the schematic forward rule:
#   {
#     1 math:atan ?r .
#     ?r math:equalTo 0.7853981633974483 .
#   } => {
#     :test-atan-1 a :MathBuiltinTest .
#     :test-atan-1 :builtin math:atan .
#     :test-atan-1 :input 1 .
#     :test-atan-1 :expected 0.7853981633974483 .
#     :test-atan-1 :actual ?r .
#     :test-atan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0.7853981633974483
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-atan-1 :builtin math:atan .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-atan-1 :input 1 .
# It holds because the following instance of the rule body is provable:
#   1 math:atan 0.7853981633974483 .
#   0.7853981633974483 math:equalTo 0.7853981633974483 .
# via the schematic forward rule:
#   {
#     1 math:atan ?r .
#     ?r math:equalTo 0.7853981633974483 .
#   } => {
#     :test-atan-1 a :MathBuiltinTest .
#     :test-atan-1 :builtin math:atan .
#     :test-atan-1 :input 1 .
#     :test-atan-1 :expected 0.7853981633974483 .
#     :test-atan-1 :actual ?r .
#     :test-atan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0.7853981633974483
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-atan-1 :input 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-atan-1 :expected 0.7853981633974483 .
# It holds because the following instance of the rule body is provable:
#   1 math:atan 0.7853981633974483 .
#   0.7853981633974483 math:equalTo 0.7853981633974483 .
# via the schematic forward rule:
#   {
#     1 math:atan ?r .
#     ?r math:equalTo 0.7853981633974483 .
#   } => {
#     :test-atan-1 a :MathBuiltinTest .
#     :test-atan-1 :builtin math:atan .
#     :test-atan-1 :input 1 .
#     :test-atan-1 :expected 0.7853981633974483 .
#     :test-atan-1 :actual ?r .
#     :test-atan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0.7853981633974483
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-atan-1 :expected 0.7853981633974483 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-atan-1 :actual 0.7853981633974483 .
# It holds because the following instance of the rule body is provable:
#   1 math:atan 0.7853981633974483 .
#   0.7853981633974483 math:equalTo 0.7853981633974483 .
# via the schematic forward rule:
#   {
#     1 math:atan ?r .
#     ?r math:equalTo 0.7853981633974483 .
#   } => {
#     :test-atan-1 a :MathBuiltinTest .
#     :test-atan-1 :builtin math:atan .
#     :test-atan-1 :input 1 .
#     :test-atan-1 :expected 0.7853981633974483 .
#     :test-atan-1 :actual ?r .
#     :test-atan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0.7853981633974483
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-atan-1 :actual 0.7853981633974483 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-atan-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   1 math:atan 0.7853981633974483 .
#   0.7853981633974483 math:equalTo 0.7853981633974483 .
# via the schematic forward rule:
#   {
#     1 math:atan ?r .
#     ?r math:equalTo 0.7853981633974483 .
#   } => {
#     :test-atan-1 a :MathBuiltinTest .
#     :test-atan-1 :builtin math:atan .
#     :test-atan-1 :input 1 .
#     :test-atan-1 :expected 0.7853981633974483 .
#     :test-atan-1 :actual ?r .
#     :test-atan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0.7853981633974483
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-atan-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cos-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:cos 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cos ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cos-1 a :MathBuiltinTest .
#     :test-cos-1 :builtin math:cos .
#     :test-cos-1 :input 0 .
#     :test-cos-1 :expected 1 .
#     :test-cos-1 :actual ?r .
#     :test-cos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cos-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cos-1 :builtin math:cos .
# It holds because the following instance of the rule body is provable:
#   0 math:cos 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cos ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cos-1 a :MathBuiltinTest .
#     :test-cos-1 :builtin math:cos .
#     :test-cos-1 :input 0 .
#     :test-cos-1 :expected 1 .
#     :test-cos-1 :actual ?r .
#     :test-cos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cos-1 :builtin math:cos .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cos-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:cos 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cos ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cos-1 a :MathBuiltinTest .
#     :test-cos-1 :builtin math:cos .
#     :test-cos-1 :input 0 .
#     :test-cos-1 :expected 1 .
#     :test-cos-1 :actual ?r .
#     :test-cos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cos-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cos-1 :expected 1 .
# It holds because the following instance of the rule body is provable:
#   0 math:cos 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cos ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cos-1 a :MathBuiltinTest .
#     :test-cos-1 :builtin math:cos .
#     :test-cos-1 :input 0 .
#     :test-cos-1 :expected 1 .
#     :test-cos-1 :actual ?r .
#     :test-cos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cos-1 :expected 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cos-1 :actual 1 .
# It holds because the following instance of the rule body is provable:
#   0 math:cos 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cos ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cos-1 a :MathBuiltinTest .
#     :test-cos-1 :builtin math:cos .
#     :test-cos-1 :input 0 .
#     :test-cos-1 :expected 1 .
#     :test-cos-1 :actual ?r .
#     :test-cos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cos-1 :actual 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cos-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:cos 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cos ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cos-1 a :MathBuiltinTest .
#     :test-cos-1 :builtin math:cos .
#     :test-cos-1 :input 0 .
#     :test-cos-1 :expected 1 .
#     :test-cos-1 :actual ?r .
#     :test-cos-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cos-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cosh-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:cosh 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cosh ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cosh-1 a :MathBuiltinTest .
#     :test-cosh-1 :builtin math:cosh .
#     :test-cosh-1 :input 0 .
#     :test-cosh-1 :expected 1 .
#     :test-cosh-1 :actual ?r .
#     :test-cosh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cosh-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cosh-1 :builtin math:cosh .
# It holds because the following instance of the rule body is provable:
#   0 math:cosh 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cosh ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cosh-1 a :MathBuiltinTest .
#     :test-cosh-1 :builtin math:cosh .
#     :test-cosh-1 :input 0 .
#     :test-cosh-1 :expected 1 .
#     :test-cosh-1 :actual ?r .
#     :test-cosh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cosh-1 :builtin math:cosh .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cosh-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:cosh 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cosh ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cosh-1 a :MathBuiltinTest .
#     :test-cosh-1 :builtin math:cosh .
#     :test-cosh-1 :input 0 .
#     :test-cosh-1 :expected 1 .
#     :test-cosh-1 :actual ?r .
#     :test-cosh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cosh-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cosh-1 :expected 1 .
# It holds because the following instance of the rule body is provable:
#   0 math:cosh 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cosh ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cosh-1 a :MathBuiltinTest .
#     :test-cosh-1 :builtin math:cosh .
#     :test-cosh-1 :input 0 .
#     :test-cosh-1 :expected 1 .
#     :test-cosh-1 :actual ?r .
#     :test-cosh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cosh-1 :expected 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cosh-1 :actual 1 .
# It holds because the following instance of the rule body is provable:
#   0 math:cosh 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cosh ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cosh-1 a :MathBuiltinTest .
#     :test-cosh-1 :builtin math:cosh .
#     :test-cosh-1 :input 0 .
#     :test-cosh-1 :expected 1 .
#     :test-cosh-1 :actual ?r .
#     :test-cosh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cosh-1 :actual 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-cosh-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:cosh 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     0 math:cosh ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-cosh-1 a :MathBuiltinTest .
#     :test-cosh-1 :builtin math:cosh .
#     :test-cosh-1 :input 0 .
#     :test-cosh-1 :expected 1 .
#     :test-cosh-1 :actual ?r .
#     :test-cosh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-cosh-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-degrees-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   3.141592653589793 math:degrees 180 .
#   180 math:equalTo 180 .
# via the schematic forward rule:
#   {
#     3.141592653589793 math:degrees ?deg .
#     ?deg math:equalTo 180 .
#   } => {
#     :test-degrees-1 a :MathBuiltinTest .
#     :test-degrees-1 :builtin math:degrees .
#     :test-degrees-1 :input 3.141592653589793 .
#     :test-degrees-1 :expected 180 .
#     :test-degrees-1 :actual ?deg .
#     :test-degrees-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?deg = 180
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-degrees-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-degrees-1 :builtin math:degrees .
# It holds because the following instance of the rule body is provable:
#   3.141592653589793 math:degrees 180 .
#   180 math:equalTo 180 .
# via the schematic forward rule:
#   {
#     3.141592653589793 math:degrees ?deg .
#     ?deg math:equalTo 180 .
#   } => {
#     :test-degrees-1 a :MathBuiltinTest .
#     :test-degrees-1 :builtin math:degrees .
#     :test-degrees-1 :input 3.141592653589793 .
#     :test-degrees-1 :expected 180 .
#     :test-degrees-1 :actual ?deg .
#     :test-degrees-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?deg = 180
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-degrees-1 :builtin math:degrees .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-degrees-1 :input 3.141592653589793 .
# It holds because the following instance of the rule body is provable:
#   3.141592653589793 math:degrees 180 .
#   180 math:equalTo 180 .
# via the schematic forward rule:
#   {
#     3.141592653589793 math:degrees ?deg .
#     ?deg math:equalTo 180 .
#   } => {
#     :test-degrees-1 a :MathBuiltinTest .
#     :test-degrees-1 :builtin math:degrees .
#     :test-degrees-1 :input 3.141592653589793 .
#     :test-degrees-1 :expected 180 .
#     :test-degrees-1 :actual ?deg .
#     :test-degrees-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?deg = 180
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-degrees-1 :input 3.141592653589793 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-degrees-1 :expected 180 .
# It holds because the following instance of the rule body is provable:
#   3.141592653589793 math:degrees 180 .
#   180 math:equalTo 180 .
# via the schematic forward rule:
#   {
#     3.141592653589793 math:degrees ?deg .
#     ?deg math:equalTo 180 .
#   } => {
#     :test-degrees-1 a :MathBuiltinTest .
#     :test-degrees-1 :builtin math:degrees .
#     :test-degrees-1 :input 3.141592653589793 .
#     :test-degrees-1 :expected 180 .
#     :test-degrees-1 :actual ?deg .
#     :test-degrees-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?deg = 180
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-degrees-1 :expected 180 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-degrees-1 :actual 180 .
# It holds because the following instance of the rule body is provable:
#   3.141592653589793 math:degrees 180 .
#   180 math:equalTo 180 .
# via the schematic forward rule:
#   {
#     3.141592653589793 math:degrees ?deg .
#     ?deg math:equalTo 180 .
#   } => {
#     :test-degrees-1 a :MathBuiltinTest .
#     :test-degrees-1 :builtin math:degrees .
#     :test-degrees-1 :input 3.141592653589793 .
#     :test-degrees-1 :expected 180 .
#     :test-degrees-1 :actual ?deg .
#     :test-degrees-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?deg = 180
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-degrees-1 :actual 180 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-degrees-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   3.141592653589793 math:degrees 180 .
#   180 math:equalTo 180 .
# via the schematic forward rule:
#   {
#     3.141592653589793 math:degrees ?deg .
#     ?deg math:equalTo 180 .
#   } => {
#     :test-degrees-1 a :MathBuiltinTest .
#     :test-degrees-1 :builtin math:degrees .
#     :test-degrees-1 :input 3.141592653589793 .
#     :test-degrees-1 :expected 180 .
#     :test-degrees-1 :actual ?deg .
#     :test-degrees-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?deg = 180
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-degrees-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:difference 5 .
#   5 math:equalTo 5 .
# via the schematic forward rule:
#   {
#     (7 2) math:difference ?d .
#     ?d math:equalTo 5 .
#   } => {
#     :test-difference-1 a :MathBuiltinTest .
#     :test-difference-1 :builtin math:difference .
#     :test-difference-1 :input (7 2) .
#     :test-difference-1 :expected 5 .
#     :test-difference-1 :actual ?d .
#     :test-difference-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = 5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-1 :builtin math:difference .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:difference 5 .
#   5 math:equalTo 5 .
# via the schematic forward rule:
#   {
#     (7 2) math:difference ?d .
#     ?d math:equalTo 5 .
#   } => {
#     :test-difference-1 a :MathBuiltinTest .
#     :test-difference-1 :builtin math:difference .
#     :test-difference-1 :input (7 2) .
#     :test-difference-1 :expected 5 .
#     :test-difference-1 :actual ?d .
#     :test-difference-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = 5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-1 :builtin math:difference .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-1 :input (7 2) .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:difference 5 .
#   5 math:equalTo 5 .
# via the schematic forward rule:
#   {
#     (7 2) math:difference ?d .
#     ?d math:equalTo 5 .
#   } => {
#     :test-difference-1 a :MathBuiltinTest .
#     :test-difference-1 :builtin math:difference .
#     :test-difference-1 :input (7 2) .
#     :test-difference-1 :expected 5 .
#     :test-difference-1 :actual ?d .
#     :test-difference-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = 5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-1 :input (7 2) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-1 :expected 5 .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:difference 5 .
#   5 math:equalTo 5 .
# via the schematic forward rule:
#   {
#     (7 2) math:difference ?d .
#     ?d math:equalTo 5 .
#   } => {
#     :test-difference-1 a :MathBuiltinTest .
#     :test-difference-1 :builtin math:difference .
#     :test-difference-1 :input (7 2) .
#     :test-difference-1 :expected 5 .
#     :test-difference-1 :actual ?d .
#     :test-difference-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = 5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-1 :expected 5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-1 :actual 5 .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:difference 5 .
#   5 math:equalTo 5 .
# via the schematic forward rule:
#   {
#     (7 2) math:difference ?d .
#     ?d math:equalTo 5 .
#   } => {
#     :test-difference-1 a :MathBuiltinTest .
#     :test-difference-1 :builtin math:difference .
#     :test-difference-1 :input (7 2) .
#     :test-difference-1 :expected 5 .
#     :test-difference-1 :actual ?d .
#     :test-difference-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = 5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-1 :actual 5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:difference 5 .
#   5 math:equalTo 5 .
# via the schematic forward rule:
#   {
#     (7 2) math:difference ?d .
#     ?d math:equalTo 5 .
#   } => {
#     :test-difference-1 a :MathBuiltinTest .
#     :test-difference-1 :builtin math:difference .
#     :test-difference-1 :input (7 2) .
#     :test-difference-1 :expected 5 .
#     :test-difference-1 :actual ?d .
#     :test-difference-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = 5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-2 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (2 7) math:difference -5 .
#   -5 math:equalTo -5 .
# via the schematic forward rule:
#   {
#     (2 7) math:difference ?d .
#     ?d math:equalTo -5 .
#   } => {
#     :test-difference-2 a :MathBuiltinTest .
#     :test-difference-2 :builtin math:difference .
#     :test-difference-2 :input (2 7) .
#     :test-difference-2 :expected -5 .
#     :test-difference-2 :actual ?d .
#     :test-difference-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = -5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-2 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-2 :builtin math:difference .
# It holds because the following instance of the rule body is provable:
#   (2 7) math:difference -5 .
#   -5 math:equalTo -5 .
# via the schematic forward rule:
#   {
#     (2 7) math:difference ?d .
#     ?d math:equalTo -5 .
#   } => {
#     :test-difference-2 a :MathBuiltinTest .
#     :test-difference-2 :builtin math:difference .
#     :test-difference-2 :input (2 7) .
#     :test-difference-2 :expected -5 .
#     :test-difference-2 :actual ?d .
#     :test-difference-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = -5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-2 :builtin math:difference .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-2 :input (2 7) .
# It holds because the following instance of the rule body is provable:
#   (2 7) math:difference -5 .
#   -5 math:equalTo -5 .
# via the schematic forward rule:
#   {
#     (2 7) math:difference ?d .
#     ?d math:equalTo -5 .
#   } => {
#     :test-difference-2 a :MathBuiltinTest .
#     :test-difference-2 :builtin math:difference .
#     :test-difference-2 :input (2 7) .
#     :test-difference-2 :expected -5 .
#     :test-difference-2 :actual ?d .
#     :test-difference-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = -5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-2 :input (2 7) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-2 :expected -5 .
# It holds because the following instance of the rule body is provable:
#   (2 7) math:difference -5 .
#   -5 math:equalTo -5 .
# via the schematic forward rule:
#   {
#     (2 7) math:difference ?d .
#     ?d math:equalTo -5 .
#   } => {
#     :test-difference-2 a :MathBuiltinTest .
#     :test-difference-2 :builtin math:difference .
#     :test-difference-2 :input (2 7) .
#     :test-difference-2 :expected -5 .
#     :test-difference-2 :actual ?d .
#     :test-difference-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = -5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-2 :expected -5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-2 :actual -5 .
# It holds because the following instance of the rule body is provable:
#   (2 7) math:difference -5 .
#   -5 math:equalTo -5 .
# via the schematic forward rule:
#   {
#     (2 7) math:difference ?d .
#     ?d math:equalTo -5 .
#   } => {
#     :test-difference-2 a :MathBuiltinTest .
#     :test-difference-2 :builtin math:difference .
#     :test-difference-2 :input (2 7) .
#     :test-difference-2 :expected -5 .
#     :test-difference-2 :actual ?d .
#     :test-difference-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = -5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-2 :actual -5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-difference-2 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (2 7) math:difference -5 .
#   -5 math:equalTo -5 .
# via the schematic forward rule:
#   {
#     (2 7) math:difference ?d .
#     ?d math:equalTo -5 .
#   } => {
#     :test-difference-2 a :MathBuiltinTest .
#     :test-difference-2 :builtin math:difference .
#     :test-difference-2 :input (2 7) .
#     :test-difference-2 :expected -5 .
#     :test-difference-2 :actual ?d .
#     :test-difference-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?d = -5
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-difference-2 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-equalTo-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     42 math:equalTo 42 .
#   } => {
#     :test-equalTo-1 a :MathBuiltinTest .
#     :test-equalTo-1 :builtin math:equalTo .
#     :test-equalTo-1 :input 42 .
#     :test-equalTo-1 :other 42 .
#     :test-equalTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-equalTo-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-equalTo-1 :builtin math:equalTo .
# It holds because the following instance of the rule body is provable:
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     42 math:equalTo 42 .
#   } => {
#     :test-equalTo-1 a :MathBuiltinTest .
#     :test-equalTo-1 :builtin math:equalTo .
#     :test-equalTo-1 :input 42 .
#     :test-equalTo-1 :other 42 .
#     :test-equalTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-equalTo-1 :builtin math:equalTo .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-equalTo-1 :input 42 .
# It holds because the following instance of the rule body is provable:
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     42 math:equalTo 42 .
#   } => {
#     :test-equalTo-1 a :MathBuiltinTest .
#     :test-equalTo-1 :builtin math:equalTo .
#     :test-equalTo-1 :input 42 .
#     :test-equalTo-1 :other 42 .
#     :test-equalTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-equalTo-1 :input 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-equalTo-1 :other 42 .
# It holds because the following instance of the rule body is provable:
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     42 math:equalTo 42 .
#   } => {
#     :test-equalTo-1 a :MathBuiltinTest .
#     :test-equalTo-1 :builtin math:equalTo .
#     :test-equalTo-1 :input 42 .
#     :test-equalTo-1 :other 42 .
#     :test-equalTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-equalTo-1 :other 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-equalTo-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     42 math:equalTo 42 .
#   } => {
#     :test-equalTo-1 a :MathBuiltinTest .
#     :test-equalTo-1 :builtin math:equalTo .
#     :test-equalTo-1 :input 42 .
#     :test-equalTo-1 :other 42 .
#     :test-equalTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-equalTo-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
#   49 math:equalTo 49 .
# via the schematic forward rule:
#   {
#     (7 2) math:exponentiation ?r .
#     ?r math:equalTo 49 .
#   } => {
#     :test-exponentiation-1 a :MathBuiltinTest .
#     :test-exponentiation-1 :builtin math:exponentiation .
#     :test-exponentiation-1 :input (7 2) .
#     :test-exponentiation-1 :expected 49 .
#     :test-exponentiation-1 :actual ?r .
#     :test-exponentiation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 49
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-1 :builtin math:exponentiation .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
#   49 math:equalTo 49 .
# via the schematic forward rule:
#   {
#     (7 2) math:exponentiation ?r .
#     ?r math:equalTo 49 .
#   } => {
#     :test-exponentiation-1 a :MathBuiltinTest .
#     :test-exponentiation-1 :builtin math:exponentiation .
#     :test-exponentiation-1 :input (7 2) .
#     :test-exponentiation-1 :expected 49 .
#     :test-exponentiation-1 :actual ?r .
#     :test-exponentiation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 49
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-1 :builtin math:exponentiation .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-1 :input (7 2) .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
#   49 math:equalTo 49 .
# via the schematic forward rule:
#   {
#     (7 2) math:exponentiation ?r .
#     ?r math:equalTo 49 .
#   } => {
#     :test-exponentiation-1 a :MathBuiltinTest .
#     :test-exponentiation-1 :builtin math:exponentiation .
#     :test-exponentiation-1 :input (7 2) .
#     :test-exponentiation-1 :expected 49 .
#     :test-exponentiation-1 :actual ?r .
#     :test-exponentiation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 49
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-1 :input (7 2) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-1 :expected 49 .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
#   49 math:equalTo 49 .
# via the schematic forward rule:
#   {
#     (7 2) math:exponentiation ?r .
#     ?r math:equalTo 49 .
#   } => {
#     :test-exponentiation-1 a :MathBuiltinTest .
#     :test-exponentiation-1 :builtin math:exponentiation .
#     :test-exponentiation-1 :input (7 2) .
#     :test-exponentiation-1 :expected 49 .
#     :test-exponentiation-1 :actual ?r .
#     :test-exponentiation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 49
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-1 :expected 49 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-1 :actual 49 .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
#   49 math:equalTo 49 .
# via the schematic forward rule:
#   {
#     (7 2) math:exponentiation ?r .
#     ?r math:equalTo 49 .
#   } => {
#     :test-exponentiation-1 a :MathBuiltinTest .
#     :test-exponentiation-1 :builtin math:exponentiation .
#     :test-exponentiation-1 :input (7 2) .
#     :test-exponentiation-1 :expected 49 .
#     :test-exponentiation-1 :actual ?r .
#     :test-exponentiation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 49
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-1 :actual 49 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
#   49 math:equalTo 49 .
# via the schematic forward rule:
#   {
#     (7 2) math:exponentiation ?r .
#     ?r math:equalTo 49 .
#   } => {
#     :test-exponentiation-1 a :MathBuiltinTest .
#     :test-exponentiation-1 :builtin math:exponentiation .
#     :test-exponentiation-1 :input (7 2) .
#     :test-exponentiation-1 :expected 49 .
#     :test-exponentiation-1 :actual ?r .
#     :test-exponentiation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 49
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-2 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
# via the schematic forward rule:
#   {
#     (7 ?exp) math:exponentiation 49 .
#   } => {
#     :test-exponentiation-2 a :MathBuiltinTest .
#     :test-exponentiation-2 :builtin math:exponentiation .
#     :test-exponentiation-2 :input (7 ?exp) .
#     :test-exponentiation-2 :expected 2 .
#     :test-exponentiation-2 :actual ?exp .
#     :test-exponentiation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?exp = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-2 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-2 :builtin math:exponentiation .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
# via the schematic forward rule:
#   {
#     (7 ?exp) math:exponentiation 49 .
#   } => {
#     :test-exponentiation-2 a :MathBuiltinTest .
#     :test-exponentiation-2 :builtin math:exponentiation .
#     :test-exponentiation-2 :input (7 ?exp) .
#     :test-exponentiation-2 :expected 2 .
#     :test-exponentiation-2 :actual ?exp .
#     :test-exponentiation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?exp = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-2 :builtin math:exponentiation .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-2 :input (7 2) .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
# via the schematic forward rule:
#   {
#     (7 ?exp) math:exponentiation 49 .
#   } => {
#     :test-exponentiation-2 a :MathBuiltinTest .
#     :test-exponentiation-2 :builtin math:exponentiation .
#     :test-exponentiation-2 :input (7 ?exp) .
#     :test-exponentiation-2 :expected 2 .
#     :test-exponentiation-2 :actual ?exp .
#     :test-exponentiation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?exp = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-2 :input (7 2) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-2 :expected 2 .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
# via the schematic forward rule:
#   {
#     (7 ?exp) math:exponentiation 49 .
#   } => {
#     :test-exponentiation-2 a :MathBuiltinTest .
#     :test-exponentiation-2 :builtin math:exponentiation .
#     :test-exponentiation-2 :input (7 ?exp) .
#     :test-exponentiation-2 :expected 2 .
#     :test-exponentiation-2 :actual ?exp .
#     :test-exponentiation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?exp = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-2 :expected 2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-2 :actual 2 .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
# via the schematic forward rule:
#   {
#     (7 ?exp) math:exponentiation 49 .
#   } => {
#     :test-exponentiation-2 a :MathBuiltinTest .
#     :test-exponentiation-2 :builtin math:exponentiation .
#     :test-exponentiation-2 :input (7 ?exp) .
#     :test-exponentiation-2 :expected 2 .
#     :test-exponentiation-2 :actual ?exp .
#     :test-exponentiation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?exp = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-2 :actual 2 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-exponentiation-2 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (7 2) math:exponentiation 49 .
# via the schematic forward rule:
#   {
#     (7 ?exp) math:exponentiation 49 .
#   } => {
#     :test-exponentiation-2 a :MathBuiltinTest .
#     :test-exponentiation-2 :builtin math:exponentiation .
#     :test-exponentiation-2 :input (7 ?exp) .
#     :test-exponentiation-2 :expected 2 .
#     :test-exponentiation-2 :actual ?exp .
#     :test-exponentiation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?exp = 2
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-exponentiation-2 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-greaterThan-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   42 math:greaterThan 41 .
# via the schematic forward rule:
#   {
#     42 math:greaterThan 41 .
#   } => {
#     :test-greaterThan-1 a :MathBuiltinTest .
#     :test-greaterThan-1 :builtin math:greaterThan .
#     :test-greaterThan-1 :input 42 .
#     :test-greaterThan-1 :other 41 .
#     :test-greaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-greaterThan-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-greaterThan-1 :builtin math:greaterThan .
# It holds because the following instance of the rule body is provable:
#   42 math:greaterThan 41 .
# via the schematic forward rule:
#   {
#     42 math:greaterThan 41 .
#   } => {
#     :test-greaterThan-1 a :MathBuiltinTest .
#     :test-greaterThan-1 :builtin math:greaterThan .
#     :test-greaterThan-1 :input 42 .
#     :test-greaterThan-1 :other 41 .
#     :test-greaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-greaterThan-1 :builtin math:greaterThan .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-greaterThan-1 :input 42 .
# It holds because the following instance of the rule body is provable:
#   42 math:greaterThan 41 .
# via the schematic forward rule:
#   {
#     42 math:greaterThan 41 .
#   } => {
#     :test-greaterThan-1 a :MathBuiltinTest .
#     :test-greaterThan-1 :builtin math:greaterThan .
#     :test-greaterThan-1 :input 42 .
#     :test-greaterThan-1 :other 41 .
#     :test-greaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-greaterThan-1 :input 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-greaterThan-1 :other 41 .
# It holds because the following instance of the rule body is provable:
#   42 math:greaterThan 41 .
# via the schematic forward rule:
#   {
#     42 math:greaterThan 41 .
#   } => {
#     :test-greaterThan-1 a :MathBuiltinTest .
#     :test-greaterThan-1 :builtin math:greaterThan .
#     :test-greaterThan-1 :input 42 .
#     :test-greaterThan-1 :other 41 .
#     :test-greaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-greaterThan-1 :other 41 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-greaterThan-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   42 math:greaterThan 41 .
# via the schematic forward rule:
#   {
#     42 math:greaterThan 41 .
#   } => {
#     :test-greaterThan-1 a :MathBuiltinTest .
#     :test-greaterThan-1 :builtin math:greaterThan .
#     :test-greaterThan-1 :input 42 .
#     :test-greaterThan-1 :other 41 .
#     :test-greaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-greaterThan-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-lessThan-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   41 math:lessThan 42 .
# via the schematic forward rule:
#   {
#     41 math:lessThan 42 .
#   } => {
#     :test-lessThan-1 a :MathBuiltinTest .
#     :test-lessThan-1 :builtin math:lessThan .
#     :test-lessThan-1 :input 41 .
#     :test-lessThan-1 :other 42 .
#     :test-lessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-lessThan-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-lessThan-1 :builtin math:lessThan .
# It holds because the following instance of the rule body is provable:
#   41 math:lessThan 42 .
# via the schematic forward rule:
#   {
#     41 math:lessThan 42 .
#   } => {
#     :test-lessThan-1 a :MathBuiltinTest .
#     :test-lessThan-1 :builtin math:lessThan .
#     :test-lessThan-1 :input 41 .
#     :test-lessThan-1 :other 42 .
#     :test-lessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-lessThan-1 :builtin math:lessThan .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-lessThan-1 :input 41 .
# It holds because the following instance of the rule body is provable:
#   41 math:lessThan 42 .
# via the schematic forward rule:
#   {
#     41 math:lessThan 42 .
#   } => {
#     :test-lessThan-1 a :MathBuiltinTest .
#     :test-lessThan-1 :builtin math:lessThan .
#     :test-lessThan-1 :input 41 .
#     :test-lessThan-1 :other 42 .
#     :test-lessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-lessThan-1 :input 41 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-lessThan-1 :other 42 .
# It holds because the following instance of the rule body is provable:
#   41 math:lessThan 42 .
# via the schematic forward rule:
#   {
#     41 math:lessThan 42 .
#   } => {
#     :test-lessThan-1 a :MathBuiltinTest .
#     :test-lessThan-1 :builtin math:lessThan .
#     :test-lessThan-1 :input 41 .
#     :test-lessThan-1 :other 42 .
#     :test-lessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-lessThan-1 :other 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-lessThan-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   41 math:lessThan 42 .
# via the schematic forward rule:
#   {
#     41 math:lessThan 42 .
#   } => {
#     :test-lessThan-1 a :MathBuiltinTest .
#     :test-lessThan-1 :builtin math:lessThan .
#     :test-lessThan-1 :input 41 .
#     :test-lessThan-1 :other 42 .
#     :test-lessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-lessThan-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   42 math:negation -42 .
#   -42 math:equalTo -42 .
# via the schematic forward rule:
#   {
#     42 math:negation ?neg .
#     ?neg math:equalTo -42 .
#   } => {
#     :test-negation-1 a :MathBuiltinTest .
#     :test-negation-1 :builtin math:negation .
#     :test-negation-1 :input 42 .
#     :test-negation-1 :expected -42 .
#     :test-negation-1 :actual ?neg .
#     :test-negation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?neg = -42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-1 :builtin math:negation .
# It holds because the following instance of the rule body is provable:
#   42 math:negation -42 .
#   -42 math:equalTo -42 .
# via the schematic forward rule:
#   {
#     42 math:negation ?neg .
#     ?neg math:equalTo -42 .
#   } => {
#     :test-negation-1 a :MathBuiltinTest .
#     :test-negation-1 :builtin math:negation .
#     :test-negation-1 :input 42 .
#     :test-negation-1 :expected -42 .
#     :test-negation-1 :actual ?neg .
#     :test-negation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?neg = -42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-1 :builtin math:negation .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-1 :input 42 .
# It holds because the following instance of the rule body is provable:
#   42 math:negation -42 .
#   -42 math:equalTo -42 .
# via the schematic forward rule:
#   {
#     42 math:negation ?neg .
#     ?neg math:equalTo -42 .
#   } => {
#     :test-negation-1 a :MathBuiltinTest .
#     :test-negation-1 :builtin math:negation .
#     :test-negation-1 :input 42 .
#     :test-negation-1 :expected -42 .
#     :test-negation-1 :actual ?neg .
#     :test-negation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?neg = -42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-1 :input 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-1 :expected -42 .
# It holds because the following instance of the rule body is provable:
#   42 math:negation -42 .
#   -42 math:equalTo -42 .
# via the schematic forward rule:
#   {
#     42 math:negation ?neg .
#     ?neg math:equalTo -42 .
#   } => {
#     :test-negation-1 a :MathBuiltinTest .
#     :test-negation-1 :builtin math:negation .
#     :test-negation-1 :input 42 .
#     :test-negation-1 :expected -42 .
#     :test-negation-1 :actual ?neg .
#     :test-negation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?neg = -42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-1 :expected -42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-1 :actual -42 .
# It holds because the following instance of the rule body is provable:
#   42 math:negation -42 .
#   -42 math:equalTo -42 .
# via the schematic forward rule:
#   {
#     42 math:negation ?neg .
#     ?neg math:equalTo -42 .
#   } => {
#     :test-negation-1 a :MathBuiltinTest .
#     :test-negation-1 :builtin math:negation .
#     :test-negation-1 :input 42 .
#     :test-negation-1 :expected -42 .
#     :test-negation-1 :actual ?neg .
#     :test-negation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?neg = -42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-1 :actual -42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   42 math:negation -42 .
#   -42 math:equalTo -42 .
# via the schematic forward rule:
#   {
#     42 math:negation ?neg .
#     ?neg math:equalTo -42 .
#   } => {
#     :test-negation-1 a :MathBuiltinTest .
#     :test-negation-1 :builtin math:negation .
#     :test-negation-1 :input 42 .
#     :test-negation-1 :expected -42 .
#     :test-negation-1 :actual ?neg .
#     :test-negation-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?neg = -42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-2 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   -1 math:negation 1 .
# via the schematic forward rule:
#   {
#     ?x math:negation 1 .
#   } => {
#     :test-negation-2 a :MathBuiltinTest .
#     :test-negation-2 :builtin math:negation .
#     :test-negation-2 :input ?x .
#     :test-negation-2 :expected -1 .
#     :test-negation-2 :actual ?x .
#     :test-negation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?x = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-2 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-2 :builtin math:negation .
# It holds because the following instance of the rule body is provable:
#   -1 math:negation 1 .
# via the schematic forward rule:
#   {
#     ?x math:negation 1 .
#   } => {
#     :test-negation-2 a :MathBuiltinTest .
#     :test-negation-2 :builtin math:negation .
#     :test-negation-2 :input ?x .
#     :test-negation-2 :expected -1 .
#     :test-negation-2 :actual ?x .
#     :test-negation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?x = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-2 :builtin math:negation .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-2 :input -1 .
# It holds because the following instance of the rule body is provable:
#   -1 math:negation 1 .
# via the schematic forward rule:
#   {
#     ?x math:negation 1 .
#   } => {
#     :test-negation-2 a :MathBuiltinTest .
#     :test-negation-2 :builtin math:negation .
#     :test-negation-2 :input ?x .
#     :test-negation-2 :expected -1 .
#     :test-negation-2 :actual ?x .
#     :test-negation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?x = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-2 :input -1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-2 :expected -1 .
# It holds because the following instance of the rule body is provable:
#   -1 math:negation 1 .
# via the schematic forward rule:
#   {
#     ?x math:negation 1 .
#   } => {
#     :test-negation-2 a :MathBuiltinTest .
#     :test-negation-2 :builtin math:negation .
#     :test-negation-2 :input ?x .
#     :test-negation-2 :expected -1 .
#     :test-negation-2 :actual ?x .
#     :test-negation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?x = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-2 :expected -1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-2 :actual -1 .
# It holds because the following instance of the rule body is provable:
#   -1 math:negation 1 .
# via the schematic forward rule:
#   {
#     ?x math:negation 1 .
#   } => {
#     :test-negation-2 a :MathBuiltinTest .
#     :test-negation-2 :builtin math:negation .
#     :test-negation-2 :input ?x .
#     :test-negation-2 :expected -1 .
#     :test-negation-2 :actual ?x .
#     :test-negation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?x = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-2 :actual -1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-negation-2 :status :pass .
# It holds because the following instance of the rule body is provable:
#   -1 math:negation 1 .
# via the schematic forward rule:
#   {
#     ?x math:negation 1 .
#   } => {
#     :test-negation-2 a :MathBuiltinTest .
#     :test-negation-2 :builtin math:negation .
#     :test-negation-2 :input ?x .
#     :test-negation-2 :expected -1 .
#     :test-negation-2 :actual ?x .
#     :test-negation-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?x = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-negation-2 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notEqualTo-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   41 math:notEqualTo 42 .
# via the schematic forward rule:
#   {
#     41 math:notEqualTo 42 .
#   } => {
#     :test-notEqualTo-1 a :MathBuiltinTest .
#     :test-notEqualTo-1 :builtin math:notEqualTo .
#     :test-notEqualTo-1 :input 41 .
#     :test-notEqualTo-1 :other 42 .
#     :test-notEqualTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notEqualTo-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notEqualTo-1 :builtin math:notEqualTo .
# It holds because the following instance of the rule body is provable:
#   41 math:notEqualTo 42 .
# via the schematic forward rule:
#   {
#     41 math:notEqualTo 42 .
#   } => {
#     :test-notEqualTo-1 a :MathBuiltinTest .
#     :test-notEqualTo-1 :builtin math:notEqualTo .
#     :test-notEqualTo-1 :input 41 .
#     :test-notEqualTo-1 :other 42 .
#     :test-notEqualTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notEqualTo-1 :builtin math:notEqualTo .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notEqualTo-1 :input 41 .
# It holds because the following instance of the rule body is provable:
#   41 math:notEqualTo 42 .
# via the schematic forward rule:
#   {
#     41 math:notEqualTo 42 .
#   } => {
#     :test-notEqualTo-1 a :MathBuiltinTest .
#     :test-notEqualTo-1 :builtin math:notEqualTo .
#     :test-notEqualTo-1 :input 41 .
#     :test-notEqualTo-1 :other 42 .
#     :test-notEqualTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notEqualTo-1 :input 41 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notEqualTo-1 :other 42 .
# It holds because the following instance of the rule body is provable:
#   41 math:notEqualTo 42 .
# via the schematic forward rule:
#   {
#     41 math:notEqualTo 42 .
#   } => {
#     :test-notEqualTo-1 a :MathBuiltinTest .
#     :test-notEqualTo-1 :builtin math:notEqualTo .
#     :test-notEqualTo-1 :input 41 .
#     :test-notEqualTo-1 :other 42 .
#     :test-notEqualTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notEqualTo-1 :other 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notEqualTo-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   41 math:notEqualTo 42 .
# via the schematic forward rule:
#   {
#     41 math:notEqualTo 42 .
#   } => {
#     :test-notEqualTo-1 a :MathBuiltinTest .
#     :test-notEqualTo-1 :builtin math:notEqualTo .
#     :test-notEqualTo-1 :input 41 .
#     :test-notEqualTo-1 :other 42 .
#     :test-notEqualTo-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notEqualTo-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notGreaterThan-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   41 math:notGreaterThan 42 .
# via the schematic forward rule:
#   {
#     41 math:notGreaterThan 42 .
#   } => {
#     :test-notGreaterThan-1 a :MathBuiltinTest .
#     :test-notGreaterThan-1 :builtin math:notGreaterThan .
#     :test-notGreaterThan-1 :input 41 .
#     :test-notGreaterThan-1 :other 42 .
#     :test-notGreaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notGreaterThan-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notGreaterThan-1 :builtin math:notGreaterThan .
# It holds because the following instance of the rule body is provable:
#   41 math:notGreaterThan 42 .
# via the schematic forward rule:
#   {
#     41 math:notGreaterThan 42 .
#   } => {
#     :test-notGreaterThan-1 a :MathBuiltinTest .
#     :test-notGreaterThan-1 :builtin math:notGreaterThan .
#     :test-notGreaterThan-1 :input 41 .
#     :test-notGreaterThan-1 :other 42 .
#     :test-notGreaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notGreaterThan-1 :builtin math:notGreaterThan .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notGreaterThan-1 :input 41 .
# It holds because the following instance of the rule body is provable:
#   41 math:notGreaterThan 42 .
# via the schematic forward rule:
#   {
#     41 math:notGreaterThan 42 .
#   } => {
#     :test-notGreaterThan-1 a :MathBuiltinTest .
#     :test-notGreaterThan-1 :builtin math:notGreaterThan .
#     :test-notGreaterThan-1 :input 41 .
#     :test-notGreaterThan-1 :other 42 .
#     :test-notGreaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notGreaterThan-1 :input 41 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notGreaterThan-1 :other 42 .
# It holds because the following instance of the rule body is provable:
#   41 math:notGreaterThan 42 .
# via the schematic forward rule:
#   {
#     41 math:notGreaterThan 42 .
#   } => {
#     :test-notGreaterThan-1 a :MathBuiltinTest .
#     :test-notGreaterThan-1 :builtin math:notGreaterThan .
#     :test-notGreaterThan-1 :input 41 .
#     :test-notGreaterThan-1 :other 42 .
#     :test-notGreaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notGreaterThan-1 :other 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notGreaterThan-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   41 math:notGreaterThan 42 .
# via the schematic forward rule:
#   {
#     41 math:notGreaterThan 42 .
#   } => {
#     :test-notGreaterThan-1 a :MathBuiltinTest .
#     :test-notGreaterThan-1 :builtin math:notGreaterThan .
#     :test-notGreaterThan-1 :input 41 .
#     :test-notGreaterThan-1 :other 42 .
#     :test-notGreaterThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notGreaterThan-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notLessThan-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   42 math:notLessThan 41 .
# via the schematic forward rule:
#   {
#     42 math:notLessThan 41 .
#   } => {
#     :test-notLessThan-1 a :MathBuiltinTest .
#     :test-notLessThan-1 :builtin math:notLessThan .
#     :test-notLessThan-1 :input 42 .
#     :test-notLessThan-1 :other 41 .
#     :test-notLessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notLessThan-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notLessThan-1 :builtin math:notLessThan .
# It holds because the following instance of the rule body is provable:
#   42 math:notLessThan 41 .
# via the schematic forward rule:
#   {
#     42 math:notLessThan 41 .
#   } => {
#     :test-notLessThan-1 a :MathBuiltinTest .
#     :test-notLessThan-1 :builtin math:notLessThan .
#     :test-notLessThan-1 :input 42 .
#     :test-notLessThan-1 :other 41 .
#     :test-notLessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notLessThan-1 :builtin math:notLessThan .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notLessThan-1 :input 42 .
# It holds because the following instance of the rule body is provable:
#   42 math:notLessThan 41 .
# via the schematic forward rule:
#   {
#     42 math:notLessThan 41 .
#   } => {
#     :test-notLessThan-1 a :MathBuiltinTest .
#     :test-notLessThan-1 :builtin math:notLessThan .
#     :test-notLessThan-1 :input 42 .
#     :test-notLessThan-1 :other 41 .
#     :test-notLessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notLessThan-1 :input 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notLessThan-1 :other 41 .
# It holds because the following instance of the rule body is provable:
#   42 math:notLessThan 41 .
# via the schematic forward rule:
#   {
#     42 math:notLessThan 41 .
#   } => {
#     :test-notLessThan-1 a :MathBuiltinTest .
#     :test-notLessThan-1 :builtin math:notLessThan .
#     :test-notLessThan-1 :input 42 .
#     :test-notLessThan-1 :other 41 .
#     :test-notLessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notLessThan-1 :other 41 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-notLessThan-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   42 math:notLessThan 41 .
# via the schematic forward rule:
#   {
#     42 math:notLessThan 41 .
#   } => {
#     :test-notLessThan-1 a :MathBuiltinTest .
#     :test-notLessThan-1 :builtin math:notLessThan .
#     :test-notLessThan-1 :input 42 .
#     :test-notLessThan-1 :other 41 .
#     :test-notLessThan-1 :status :pass .
#   } .
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-notLessThan-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (2 21) math:product 42 .
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     (2 21) math:product ?p .
#     ?p math:equalTo 42 .
#   } => {
#     :test-product-1 a :MathBuiltinTest .
#     :test-product-1 :builtin math:product .
#     :test-product-1 :input (2 21) .
#     :test-product-1 :expected 42 .
#     :test-product-1 :actual ?p .
#     :test-product-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-1 :builtin math:product .
# It holds because the following instance of the rule body is provable:
#   (2 21) math:product 42 .
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     (2 21) math:product ?p .
#     ?p math:equalTo 42 .
#   } => {
#     :test-product-1 a :MathBuiltinTest .
#     :test-product-1 :builtin math:product .
#     :test-product-1 :input (2 21) .
#     :test-product-1 :expected 42 .
#     :test-product-1 :actual ?p .
#     :test-product-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-1 :builtin math:product .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-1 :input (2 21) .
# It holds because the following instance of the rule body is provable:
#   (2 21) math:product 42 .
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     (2 21) math:product ?p .
#     ?p math:equalTo 42 .
#   } => {
#     :test-product-1 a :MathBuiltinTest .
#     :test-product-1 :builtin math:product .
#     :test-product-1 :input (2 21) .
#     :test-product-1 :expected 42 .
#     :test-product-1 :actual ?p .
#     :test-product-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-1 :input (2 21) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-1 :expected 42 .
# It holds because the following instance of the rule body is provable:
#   (2 21) math:product 42 .
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     (2 21) math:product ?p .
#     ?p math:equalTo 42 .
#   } => {
#     :test-product-1 a :MathBuiltinTest .
#     :test-product-1 :builtin math:product .
#     :test-product-1 :input (2 21) .
#     :test-product-1 :expected 42 .
#     :test-product-1 :actual ?p .
#     :test-product-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-1 :expected 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-1 :actual 42 .
# It holds because the following instance of the rule body is provable:
#   (2 21) math:product 42 .
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     (2 21) math:product ?p .
#     ?p math:equalTo 42 .
#   } => {
#     :test-product-1 a :MathBuiltinTest .
#     :test-product-1 :builtin math:product .
#     :test-product-1 :input (2 21) .
#     :test-product-1 :expected 42 .
#     :test-product-1 :actual ?p .
#     :test-product-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-1 :actual 42 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (2 21) math:product 42 .
#   42 math:equalTo 42 .
# via the schematic forward rule:
#   {
#     (2 21) math:product ?p .
#     ?p math:equalTo 42 .
#   } => {
#     :test-product-1 a :MathBuiltinTest .
#     :test-product-1 :builtin math:product .
#     :test-product-1 :input (2 21) .
#     :test-product-1 :expected 42 .
#     :test-product-1 :actual ?p .
#     :test-product-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 42
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-2 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (2 4 6 8) math:product 384 .
#   384 math:equalTo 384 .
# via the schematic forward rule:
#   {
#     (2 4 6 8) math:product ?p .
#     ?p math:equalTo 384 .
#   } => {
#     :test-product-2 a :MathBuiltinTest .
#     :test-product-2 :builtin math:product .
#     :test-product-2 :input (2 4 6 8) .
#     :test-product-2 :expected 384 .
#     :test-product-2 :actual ?p .
#     :test-product-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 384
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-2 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-2 :builtin math:product .
# It holds because the following instance of the rule body is provable:
#   (2 4 6 8) math:product 384 .
#   384 math:equalTo 384 .
# via the schematic forward rule:
#   {
#     (2 4 6 8) math:product ?p .
#     ?p math:equalTo 384 .
#   } => {
#     :test-product-2 a :MathBuiltinTest .
#     :test-product-2 :builtin math:product .
#     :test-product-2 :input (2 4 6 8) .
#     :test-product-2 :expected 384 .
#     :test-product-2 :actual ?p .
#     :test-product-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 384
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-2 :builtin math:product .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-2 :input (2 4 6 8) .
# It holds because the following instance of the rule body is provable:
#   (2 4 6 8) math:product 384 .
#   384 math:equalTo 384 .
# via the schematic forward rule:
#   {
#     (2 4 6 8) math:product ?p .
#     ?p math:equalTo 384 .
#   } => {
#     :test-product-2 a :MathBuiltinTest .
#     :test-product-2 :builtin math:product .
#     :test-product-2 :input (2 4 6 8) .
#     :test-product-2 :expected 384 .
#     :test-product-2 :actual ?p .
#     :test-product-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 384
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-2 :input (2 4 6 8) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-2 :expected 384 .
# It holds because the following instance of the rule body is provable:
#   (2 4 6 8) math:product 384 .
#   384 math:equalTo 384 .
# via the schematic forward rule:
#   {
#     (2 4 6 8) math:product ?p .
#     ?p math:equalTo 384 .
#   } => {
#     :test-product-2 a :MathBuiltinTest .
#     :test-product-2 :builtin math:product .
#     :test-product-2 :input (2 4 6 8) .
#     :test-product-2 :expected 384 .
#     :test-product-2 :actual ?p .
#     :test-product-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 384
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-2 :expected 384 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-2 :actual 384 .
# It holds because the following instance of the rule body is provable:
#   (2 4 6 8) math:product 384 .
#   384 math:equalTo 384 .
# via the schematic forward rule:
#   {
#     (2 4 6 8) math:product ?p .
#     ?p math:equalTo 384 .
#   } => {
#     :test-product-2 a :MathBuiltinTest .
#     :test-product-2 :builtin math:product .
#     :test-product-2 :input (2 4 6 8) .
#     :test-product-2 :expected 384 .
#     :test-product-2 :actual ?p .
#     :test-product-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 384
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-2 :actual 384 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-product-2 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (2 4 6 8) math:product 384 .
#   384 math:equalTo 384 .
# via the schematic forward rule:
#   {
#     (2 4 6 8) math:product ?p .
#     ?p math:equalTo 384 .
#   } => {
#     :test-product-2 a :MathBuiltinTest .
#     :test-product-2 :builtin math:product .
#     :test-product-2 :input (2 4 6 8) .
#     :test-product-2 :expected 384 .
#     :test-product-2 :actual ?p .
#     :test-product-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?p = 384
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-product-2 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-quotient-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (42 2) math:quotient 21 .
#   21 math:equalTo 21 .
# via the schematic forward rule:
#   {
#     (42 2) math:quotient ?q .
#     ?q math:equalTo 21 .
#   } => {
#     :test-quotient-1 a :MathBuiltinTest .
#     :test-quotient-1 :builtin math:quotient .
#     :test-quotient-1 :input (42 2) .
#     :test-quotient-1 :expected 21 .
#     :test-quotient-1 :actual ?q .
#     :test-quotient-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?q = 21
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-quotient-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-quotient-1 :builtin math:quotient .
# It holds because the following instance of the rule body is provable:
#   (42 2) math:quotient 21 .
#   21 math:equalTo 21 .
# via the schematic forward rule:
#   {
#     (42 2) math:quotient ?q .
#     ?q math:equalTo 21 .
#   } => {
#     :test-quotient-1 a :MathBuiltinTest .
#     :test-quotient-1 :builtin math:quotient .
#     :test-quotient-1 :input (42 2) .
#     :test-quotient-1 :expected 21 .
#     :test-quotient-1 :actual ?q .
#     :test-quotient-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?q = 21
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-quotient-1 :builtin math:quotient .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-quotient-1 :input (42 2) .
# It holds because the following instance of the rule body is provable:
#   (42 2) math:quotient 21 .
#   21 math:equalTo 21 .
# via the schematic forward rule:
#   {
#     (42 2) math:quotient ?q .
#     ?q math:equalTo 21 .
#   } => {
#     :test-quotient-1 a :MathBuiltinTest .
#     :test-quotient-1 :builtin math:quotient .
#     :test-quotient-1 :input (42 2) .
#     :test-quotient-1 :expected 21 .
#     :test-quotient-1 :actual ?q .
#     :test-quotient-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?q = 21
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-quotient-1 :input (42 2) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-quotient-1 :expected 21 .
# It holds because the following instance of the rule body is provable:
#   (42 2) math:quotient 21 .
#   21 math:equalTo 21 .
# via the schematic forward rule:
#   {
#     (42 2) math:quotient ?q .
#     ?q math:equalTo 21 .
#   } => {
#     :test-quotient-1 a :MathBuiltinTest .
#     :test-quotient-1 :builtin math:quotient .
#     :test-quotient-1 :input (42 2) .
#     :test-quotient-1 :expected 21 .
#     :test-quotient-1 :actual ?q .
#     :test-quotient-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?q = 21
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-quotient-1 :expected 21 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-quotient-1 :actual 21 .
# It holds because the following instance of the rule body is provable:
#   (42 2) math:quotient 21 .
#   21 math:equalTo 21 .
# via the schematic forward rule:
#   {
#     (42 2) math:quotient ?q .
#     ?q math:equalTo 21 .
#   } => {
#     :test-quotient-1 a :MathBuiltinTest .
#     :test-quotient-1 :builtin math:quotient .
#     :test-quotient-1 :input (42 2) .
#     :test-quotient-1 :expected 21 .
#     :test-quotient-1 :actual ?q .
#     :test-quotient-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?q = 21
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-quotient-1 :actual 21 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-quotient-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (42 2) math:quotient 21 .
#   21 math:equalTo 21 .
# via the schematic forward rule:
#   {
#     (42 2) math:quotient ?q .
#     ?q math:equalTo 21 .
#   } => {
#     :test-quotient-1 a :MathBuiltinTest .
#     :test-quotient-1 :builtin math:quotient .
#     :test-quotient-1 :input (42 2) .
#     :test-quotient-1 :expected 21 .
#     :test-quotient-1 :actual ?q .
#     :test-quotient-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?q = 21
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-quotient-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-remainder-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (10 3) math:remainder 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     (10 3) math:remainder ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-remainder-1 a :MathBuiltinTest .
#     :test-remainder-1 :builtin math:remainder .
#     :test-remainder-1 :input (10 3) .
#     :test-remainder-1 :expected 1 .
#     :test-remainder-1 :actual ?r .
#     :test-remainder-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-remainder-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-remainder-1 :builtin math:remainder .
# It holds because the following instance of the rule body is provable:
#   (10 3) math:remainder 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     (10 3) math:remainder ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-remainder-1 a :MathBuiltinTest .
#     :test-remainder-1 :builtin math:remainder .
#     :test-remainder-1 :input (10 3) .
#     :test-remainder-1 :expected 1 .
#     :test-remainder-1 :actual ?r .
#     :test-remainder-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-remainder-1 :builtin math:remainder .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-remainder-1 :input (10 3) .
# It holds because the following instance of the rule body is provable:
#   (10 3) math:remainder 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     (10 3) math:remainder ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-remainder-1 a :MathBuiltinTest .
#     :test-remainder-1 :builtin math:remainder .
#     :test-remainder-1 :input (10 3) .
#     :test-remainder-1 :expected 1 .
#     :test-remainder-1 :actual ?r .
#     :test-remainder-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-remainder-1 :input (10 3) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-remainder-1 :expected 1 .
# It holds because the following instance of the rule body is provable:
#   (10 3) math:remainder 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     (10 3) math:remainder ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-remainder-1 a :MathBuiltinTest .
#     :test-remainder-1 :builtin math:remainder .
#     :test-remainder-1 :input (10 3) .
#     :test-remainder-1 :expected 1 .
#     :test-remainder-1 :actual ?r .
#     :test-remainder-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-remainder-1 :expected 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-remainder-1 :actual 1 .
# It holds because the following instance of the rule body is provable:
#   (10 3) math:remainder 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     (10 3) math:remainder ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-remainder-1 a :MathBuiltinTest .
#     :test-remainder-1 :builtin math:remainder .
#     :test-remainder-1 :input (10 3) .
#     :test-remainder-1 :expected 1 .
#     :test-remainder-1 :actual ?r .
#     :test-remainder-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-remainder-1 :actual 1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-remainder-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (10 3) math:remainder 1 .
#   1 math:equalTo 1 .
# via the schematic forward rule:
#   {
#     (10 3) math:remainder ?r .
#     ?r math:equalTo 1 .
#   } => {
#     :test-remainder-1 a :MathBuiltinTest .
#     :test-remainder-1 :builtin math:remainder .
#     :test-remainder-1 :input (10 3) .
#     :test-remainder-1 :expected 1 .
#     :test-remainder-1 :actual ?r .
#     :test-remainder-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-remainder-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded ?r .
#     ?r math:equalTo 3 .
#   } => {
#     :test-rounded-1 a :MathBuiltinTest .
#     :test-rounded-1 :builtin math:rounded .
#     :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
#     :test-rounded-1 :expected 3 .
#     :test-rounded-1 :actual ?r .
#     :test-rounded-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-1 :builtin math:rounded .
# It holds because the following instance of the rule body is provable:
#   "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded ?r .
#     ?r math:equalTo 3 .
#   } => {
#     :test-rounded-1 a :MathBuiltinTest .
#     :test-rounded-1 :builtin math:rounded .
#     :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
#     :test-rounded-1 :expected 3 .
#     :test-rounded-1 :actual ?r .
#     :test-rounded-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-1 :builtin math:rounded .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
# It holds because the following instance of the rule body is provable:
#   "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded ?r .
#     ?r math:equalTo 3 .
#   } => {
#     :test-rounded-1 a :MathBuiltinTest .
#     :test-rounded-1 :builtin math:rounded .
#     :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
#     :test-rounded-1 :expected 3 .
#     :test-rounded-1 :actual ?r .
#     :test-rounded-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-1 :expected 3 .
# It holds because the following instance of the rule body is provable:
#   "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded ?r .
#     ?r math:equalTo 3 .
#   } => {
#     :test-rounded-1 a :MathBuiltinTest .
#     :test-rounded-1 :builtin math:rounded .
#     :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
#     :test-rounded-1 :expected 3 .
#     :test-rounded-1 :actual ?r .
#     :test-rounded-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-1 :expected 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-1 :actual 3 .
# It holds because the following instance of the rule body is provable:
#   "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded ?r .
#     ?r math:equalTo 3 .
#   } => {
#     :test-rounded-1 a :MathBuiltinTest .
#     :test-rounded-1 :builtin math:rounded .
#     :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
#     :test-rounded-1 :expected 3 .
#     :test-rounded-1 :actual ?r .
#     :test-rounded-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-1 :actual 3 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded 3 .
#   3 math:equalTo 3 .
# via the schematic forward rule:
#   {
#     "3.3"^^<http://www.w3.org/2001/XMLSchema#double> math:rounded ?r .
#     ?r math:equalTo 3 .
#   } => {
#     :test-rounded-1 a :MathBuiltinTest .
#     :test-rounded-1 :builtin math:rounded .
#     :test-rounded-1 :input "3.3"^^<http://www.w3.org/2001/XMLSchema#double> .
#     :test-rounded-1 :expected 3 .
#     :test-rounded-1 :actual ?r .
#     :test-rounded-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 3
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-2 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   3.5 math:rounded 4 .
#   4 math:equalTo 4 .
# via the schematic forward rule:
#   {
#     3.5 math:rounded ?r .
#     ?r math:equalTo 4 .
#   } => {
#     :test-rounded-2 a :MathBuiltinTest .
#     :test-rounded-2 :builtin math:rounded .
#     :test-rounded-2 :input 3.5 .
#     :test-rounded-2 :expected 4 .
#     :test-rounded-2 :actual ?r .
#     :test-rounded-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-2 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-2 :builtin math:rounded .
# It holds because the following instance of the rule body is provable:
#   3.5 math:rounded 4 .
#   4 math:equalTo 4 .
# via the schematic forward rule:
#   {
#     3.5 math:rounded ?r .
#     ?r math:equalTo 4 .
#   } => {
#     :test-rounded-2 a :MathBuiltinTest .
#     :test-rounded-2 :builtin math:rounded .
#     :test-rounded-2 :input 3.5 .
#     :test-rounded-2 :expected 4 .
#     :test-rounded-2 :actual ?r .
#     :test-rounded-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-2 :builtin math:rounded .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-2 :input 3.5 .
# It holds because the following instance of the rule body is provable:
#   3.5 math:rounded 4 .
#   4 math:equalTo 4 .
# via the schematic forward rule:
#   {
#     3.5 math:rounded ?r .
#     ?r math:equalTo 4 .
#   } => {
#     :test-rounded-2 a :MathBuiltinTest .
#     :test-rounded-2 :builtin math:rounded .
#     :test-rounded-2 :input 3.5 .
#     :test-rounded-2 :expected 4 .
#     :test-rounded-2 :actual ?r .
#     :test-rounded-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-2 :input 3.5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-2 :expected 4 .
# It holds because the following instance of the rule body is provable:
#   3.5 math:rounded 4 .
#   4 math:equalTo 4 .
# via the schematic forward rule:
#   {
#     3.5 math:rounded ?r .
#     ?r math:equalTo 4 .
#   } => {
#     :test-rounded-2 a :MathBuiltinTest .
#     :test-rounded-2 :builtin math:rounded .
#     :test-rounded-2 :input 3.5 .
#     :test-rounded-2 :expected 4 .
#     :test-rounded-2 :actual ?r .
#     :test-rounded-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-2 :expected 4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-2 :actual 4 .
# It holds because the following instance of the rule body is provable:
#   3.5 math:rounded 4 .
#   4 math:equalTo 4 .
# via the schematic forward rule:
#   {
#     3.5 math:rounded ?r .
#     ?r math:equalTo 4 .
#   } => {
#     :test-rounded-2 a :MathBuiltinTest .
#     :test-rounded-2 :builtin math:rounded .
#     :test-rounded-2 :input 3.5 .
#     :test-rounded-2 :expected 4 .
#     :test-rounded-2 :actual ?r .
#     :test-rounded-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-2 :actual 4 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-2 :status :pass .
# It holds because the following instance of the rule body is provable:
#   3.5 math:rounded 4 .
#   4 math:equalTo 4 .
# via the schematic forward rule:
#   {
#     3.5 math:rounded ?r .
#     ?r math:equalTo 4 .
#   } => {
#     :test-rounded-2 a :MathBuiltinTest .
#     :test-rounded-2 :builtin math:rounded .
#     :test-rounded-2 :input 3.5 .
#     :test-rounded-2 :expected 4 .
#     :test-rounded-2 :actual ?r .
#     :test-rounded-2 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 4
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-2 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-3 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   -1.5 math:rounded -1 .
#   -1 math:equalTo -1 .
# via the schematic forward rule:
#   {
#     -1.5 math:rounded ?r .
#     ?r math:equalTo -1 .
#   } => {
#     :test-rounded-3 a :MathBuiltinTest .
#     :test-rounded-3 :builtin math:rounded .
#     :test-rounded-3 :input -1.5 .
#     :test-rounded-3 :expected -1 .
#     :test-rounded-3 :actual ?r .
#     :test-rounded-3 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-3 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-3 :builtin math:rounded .
# It holds because the following instance of the rule body is provable:
#   -1.5 math:rounded -1 .
#   -1 math:equalTo -1 .
# via the schematic forward rule:
#   {
#     -1.5 math:rounded ?r .
#     ?r math:equalTo -1 .
#   } => {
#     :test-rounded-3 a :MathBuiltinTest .
#     :test-rounded-3 :builtin math:rounded .
#     :test-rounded-3 :input -1.5 .
#     :test-rounded-3 :expected -1 .
#     :test-rounded-3 :actual ?r .
#     :test-rounded-3 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-3 :builtin math:rounded .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-3 :input -1.5 .
# It holds because the following instance of the rule body is provable:
#   -1.5 math:rounded -1 .
#   -1 math:equalTo -1 .
# via the schematic forward rule:
#   {
#     -1.5 math:rounded ?r .
#     ?r math:equalTo -1 .
#   } => {
#     :test-rounded-3 a :MathBuiltinTest .
#     :test-rounded-3 :builtin math:rounded .
#     :test-rounded-3 :input -1.5 .
#     :test-rounded-3 :expected -1 .
#     :test-rounded-3 :actual ?r .
#     :test-rounded-3 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-3 :input -1.5 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-3 :expected -1 .
# It holds because the following instance of the rule body is provable:
#   -1.5 math:rounded -1 .
#   -1 math:equalTo -1 .
# via the schematic forward rule:
#   {
#     -1.5 math:rounded ?r .
#     ?r math:equalTo -1 .
#   } => {
#     :test-rounded-3 a :MathBuiltinTest .
#     :test-rounded-3 :builtin math:rounded .
#     :test-rounded-3 :input -1.5 .
#     :test-rounded-3 :expected -1 .
#     :test-rounded-3 :actual ?r .
#     :test-rounded-3 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-3 :expected -1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-3 :actual -1 .
# It holds because the following instance of the rule body is provable:
#   -1.5 math:rounded -1 .
#   -1 math:equalTo -1 .
# via the schematic forward rule:
#   {
#     -1.5 math:rounded ?r .
#     ?r math:equalTo -1 .
#   } => {
#     :test-rounded-3 a :MathBuiltinTest .
#     :test-rounded-3 :builtin math:rounded .
#     :test-rounded-3 :input -1.5 .
#     :test-rounded-3 :expected -1 .
#     :test-rounded-3 :actual ?r .
#     :test-rounded-3 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-3 :actual -1 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-rounded-3 :status :pass .
# It holds because the following instance of the rule body is provable:
#   -1.5 math:rounded -1 .
#   -1 math:equalTo -1 .
# via the schematic forward rule:
#   {
#     -1.5 math:rounded ?r .
#     ?r math:equalTo -1 .
#   } => {
#     :test-rounded-3 a :MathBuiltinTest .
#     :test-rounded-3 :builtin math:rounded .
#     :test-rounded-3 :input -1.5 .
#     :test-rounded-3 :expected -1 .
#     :test-rounded-3 :actual ?r .
#     :test-rounded-3 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = -1
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-rounded-3 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sin-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:sin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sin-1 a :MathBuiltinTest .
#     :test-sin-1 :builtin math:sin .
#     :test-sin-1 :input 0 .
#     :test-sin-1 :expected 0 .
#     :test-sin-1 :actual ?r .
#     :test-sin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sin-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sin-1 :builtin math:sin .
# It holds because the following instance of the rule body is provable:
#   0 math:sin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sin-1 a :MathBuiltinTest .
#     :test-sin-1 :builtin math:sin .
#     :test-sin-1 :input 0 .
#     :test-sin-1 :expected 0 .
#     :test-sin-1 :actual ?r .
#     :test-sin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sin-1 :builtin math:sin .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sin-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:sin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sin-1 a :MathBuiltinTest .
#     :test-sin-1 :builtin math:sin .
#     :test-sin-1 :input 0 .
#     :test-sin-1 :expected 0 .
#     :test-sin-1 :actual ?r .
#     :test-sin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sin-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sin-1 :expected 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:sin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sin-1 a :MathBuiltinTest .
#     :test-sin-1 :builtin math:sin .
#     :test-sin-1 :input 0 .
#     :test-sin-1 :expected 0 .
#     :test-sin-1 :actual ?r .
#     :test-sin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sin-1 :expected 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sin-1 :actual 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:sin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sin-1 a :MathBuiltinTest .
#     :test-sin-1 :builtin math:sin .
#     :test-sin-1 :input 0 .
#     :test-sin-1 :expected 0 .
#     :test-sin-1 :actual ?r .
#     :test-sin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sin-1 :actual 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sin-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:sin 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sin ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sin-1 a :MathBuiltinTest .
#     :test-sin-1 :builtin math:sin .
#     :test-sin-1 :input 0 .
#     :test-sin-1 :expected 0 .
#     :test-sin-1 :actual ?r .
#     :test-sin-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sin-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sinh-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:sinh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sinh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sinh-1 a :MathBuiltinTest .
#     :test-sinh-1 :builtin math:sinh .
#     :test-sinh-1 :input 0 .
#     :test-sinh-1 :expected 0 .
#     :test-sinh-1 :actual ?r .
#     :test-sinh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sinh-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sinh-1 :builtin math:sinh .
# It holds because the following instance of the rule body is provable:
#   0 math:sinh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sinh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sinh-1 a :MathBuiltinTest .
#     :test-sinh-1 :builtin math:sinh .
#     :test-sinh-1 :input 0 .
#     :test-sinh-1 :expected 0 .
#     :test-sinh-1 :actual ?r .
#     :test-sinh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sinh-1 :builtin math:sinh .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sinh-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:sinh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sinh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sinh-1 a :MathBuiltinTest .
#     :test-sinh-1 :builtin math:sinh .
#     :test-sinh-1 :input 0 .
#     :test-sinh-1 :expected 0 .
#     :test-sinh-1 :actual ?r .
#     :test-sinh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sinh-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sinh-1 :expected 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:sinh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sinh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sinh-1 a :MathBuiltinTest .
#     :test-sinh-1 :builtin math:sinh .
#     :test-sinh-1 :input 0 .
#     :test-sinh-1 :expected 0 .
#     :test-sinh-1 :actual ?r .
#     :test-sinh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sinh-1 :expected 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sinh-1 :actual 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:sinh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sinh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sinh-1 a :MathBuiltinTest .
#     :test-sinh-1 :builtin math:sinh .
#     :test-sinh-1 :input 0 .
#     :test-sinh-1 :expected 0 .
#     :test-sinh-1 :actual ?r .
#     :test-sinh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sinh-1 :actual 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sinh-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:sinh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:sinh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-sinh-1 a :MathBuiltinTest .
#     :test-sinh-1 :builtin math:sinh .
#     :test-sinh-1 :input 0 .
#     :test-sinh-1 :expected 0 .
#     :test-sinh-1 :actual ?r .
#     :test-sinh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sinh-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sum-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   (1 2 3 4 5 6 7 8 9 10) math:sum 55 .
#   55 math:equalTo 55 .
# via the schematic forward rule:
#   {
#     (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
#     ?s math:equalTo 55 .
#   } => {
#     :test-sum-1 a :MathBuiltinTest .
#     :test-sum-1 :builtin math:sum .
#     :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
#     :test-sum-1 :expected 55 .
#     :test-sum-1 :actual ?s .
#     :test-sum-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?s = 55
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sum-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sum-1 :builtin math:sum .
# It holds because the following instance of the rule body is provable:
#   (1 2 3 4 5 6 7 8 9 10) math:sum 55 .
#   55 math:equalTo 55 .
# via the schematic forward rule:
#   {
#     (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
#     ?s math:equalTo 55 .
#   } => {
#     :test-sum-1 a :MathBuiltinTest .
#     :test-sum-1 :builtin math:sum .
#     :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
#     :test-sum-1 :expected 55 .
#     :test-sum-1 :actual ?s .
#     :test-sum-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?s = 55
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sum-1 :builtin math:sum .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
# It holds because the following instance of the rule body is provable:
#   (1 2 3 4 5 6 7 8 9 10) math:sum 55 .
#   55 math:equalTo 55 .
# via the schematic forward rule:
#   {
#     (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
#     ?s math:equalTo 55 .
#   } => {
#     :test-sum-1 a :MathBuiltinTest .
#     :test-sum-1 :builtin math:sum .
#     :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
#     :test-sum-1 :expected 55 .
#     :test-sum-1 :actual ?s .
#     :test-sum-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?s = 55
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sum-1 :expected 55 .
# It holds because the following instance of the rule body is provable:
#   (1 2 3 4 5 6 7 8 9 10) math:sum 55 .
#   55 math:equalTo 55 .
# via the schematic forward rule:
#   {
#     (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
#     ?s math:equalTo 55 .
#   } => {
#     :test-sum-1 a :MathBuiltinTest .
#     :test-sum-1 :builtin math:sum .
#     :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
#     :test-sum-1 :expected 55 .
#     :test-sum-1 :actual ?s .
#     :test-sum-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?s = 55
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sum-1 :expected 55 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sum-1 :actual 55 .
# It holds because the following instance of the rule body is provable:
#   (1 2 3 4 5 6 7 8 9 10) math:sum 55 .
#   55 math:equalTo 55 .
# via the schematic forward rule:
#   {
#     (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
#     ?s math:equalTo 55 .
#   } => {
#     :test-sum-1 a :MathBuiltinTest .
#     :test-sum-1 :builtin math:sum .
#     :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
#     :test-sum-1 :expected 55 .
#     :test-sum-1 :actual ?s .
#     :test-sum-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?s = 55
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sum-1 :actual 55 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-sum-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   (1 2 3 4 5 6 7 8 9 10) math:sum 55 .
#   55 math:equalTo 55 .
# via the schematic forward rule:
#   {
#     (1 2 3 4 5 6 7 8 9 10) math:sum ?s .
#     ?s math:equalTo 55 .
#   } => {
#     :test-sum-1 a :MathBuiltinTest .
#     :test-sum-1 :builtin math:sum .
#     :test-sum-1 :input (1 2 3 4 5 6 7 8 9 10) .
#     :test-sum-1 :expected 55 .
#     :test-sum-1 :actual ?s .
#     :test-sum-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?s = 55
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-sum-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tan-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:tan 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tan ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tan-1 a :MathBuiltinTest .
#     :test-tan-1 :builtin math:tan .
#     :test-tan-1 :input 0 .
#     :test-tan-1 :expected 0 .
#     :test-tan-1 :actual ?r .
#     :test-tan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tan-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tan-1 :builtin math:tan .
# It holds because the following instance of the rule body is provable:
#   0 math:tan 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tan ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tan-1 a :MathBuiltinTest .
#     :test-tan-1 :builtin math:tan .
#     :test-tan-1 :input 0 .
#     :test-tan-1 :expected 0 .
#     :test-tan-1 :actual ?r .
#     :test-tan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tan-1 :builtin math:tan .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tan-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:tan 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tan ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tan-1 a :MathBuiltinTest .
#     :test-tan-1 :builtin math:tan .
#     :test-tan-1 :input 0 .
#     :test-tan-1 :expected 0 .
#     :test-tan-1 :actual ?r .
#     :test-tan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tan-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tan-1 :expected 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:tan 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tan ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tan-1 a :MathBuiltinTest .
#     :test-tan-1 :builtin math:tan .
#     :test-tan-1 :input 0 .
#     :test-tan-1 :expected 0 .
#     :test-tan-1 :actual ?r .
#     :test-tan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tan-1 :expected 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tan-1 :actual 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:tan 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tan ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tan-1 a :MathBuiltinTest .
#     :test-tan-1 :builtin math:tan .
#     :test-tan-1 :input 0 .
#     :test-tan-1 :expected 0 .
#     :test-tan-1 :actual ?r .
#     :test-tan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tan-1 :actual 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tan-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:tan 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tan ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tan-1 a :MathBuiltinTest .
#     :test-tan-1 :builtin math:tan .
#     :test-tan-1 :input 0 .
#     :test-tan-1 :expected 0 .
#     :test-tan-1 :actual ?r .
#     :test-tan-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tan-1 :status :pass .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tanh-1 a :MathBuiltinTest .
# It holds because the following instance of the rule body is provable:
#   0 math:tanh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tanh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tanh-1 a :MathBuiltinTest .
#     :test-tanh-1 :builtin math:tanh .
#     :test-tanh-1 :input 0 .
#     :test-tanh-1 :expected 0 .
#     :test-tanh-1 :actual ?r .
#     :test-tanh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tanh-1 a :MathBuiltinTest .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tanh-1 :builtin math:tanh .
# It holds because the following instance of the rule body is provable:
#   0 math:tanh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tanh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tanh-1 a :MathBuiltinTest .
#     :test-tanh-1 :builtin math:tanh .
#     :test-tanh-1 :input 0 .
#     :test-tanh-1 :expected 0 .
#     :test-tanh-1 :actual ?r .
#     :test-tanh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tanh-1 :builtin math:tanh .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tanh-1 :input 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:tanh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tanh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tanh-1 a :MathBuiltinTest .
#     :test-tanh-1 :builtin math:tanh .
#     :test-tanh-1 :input 0 .
#     :test-tanh-1 :expected 0 .
#     :test-tanh-1 :actual ?r .
#     :test-tanh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tanh-1 :input 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tanh-1 :expected 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:tanh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tanh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tanh-1 a :MathBuiltinTest .
#     :test-tanh-1 :builtin math:tanh .
#     :test-tanh-1 :input 0 .
#     :test-tanh-1 :expected 0 .
#     :test-tanh-1 :actual ?r .
#     :test-tanh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tanh-1 :expected 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tanh-1 :actual 0 .
# It holds because the following instance of the rule body is provable:
#   0 math:tanh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tanh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tanh-1 a :MathBuiltinTest .
#     :test-tanh-1 :builtin math:tanh .
#     :test-tanh-1 :input 0 .
#     :test-tanh-1 :expected 0 .
#     :test-tanh-1 :actual ?r .
#     :test-tanh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tanh-1 :actual 0 .

# ----------------------------------------------------------------------
# Proof for derived triple:
#   :test-tanh-1 :status :pass .
# It holds because the following instance of the rule body is provable:
#   0 math:tanh 0 .
#   0 math:equalTo 0 .
# via the schematic forward rule:
#   {
#     0 math:tanh ?r .
#     ?r math:equalTo 0 .
#   } => {
#     :test-tanh-1 a :MathBuiltinTest .
#     :test-tanh-1 :builtin math:tanh .
#     :test-tanh-1 :input 0 .
#     :test-tanh-1 :expected 0 .
#     :test-tanh-1 :actual ?r .
#     :test-tanh-1 :status :pass .
#   } .
# with substitution (on rule variables):
#   ?r = 0
# Therefore the derived triple above is entailed by the rules and facts.
# ----------------------------------------------------------------------

:test-tanh-1 :status :pass .

